
- Jedis - Redis Cluster, HBase 환경
- 레디스 클러스터
    - 레디스 클러스터는 데이터가 해시 슬롯 단위로 보관된다. 슬롯은  개로 수평하게 분할해서 클러스터링한다.
    - 데이터를 어떤 슬롯에 저장할지는 (키의 CRC15 값) / (슬롯 개수) 로 결정된다.
- Lua scripting
    - 레디스 내부 Lua 인터프리터로 임의의 명령어를 조합하여 수행. EVAL 커맨드
    - 스크립트 자체가 하나의 큰 명령어로 해석되어 atomic하게 처리됨
- 스크립트가 너무 길면 SCRIPT LOAD로 미리 캐싱해둔 후 EVALSHA로 실행 가능
    - 노드 / 키 관리에 소요되는 비용과 네트워크 대역 절감 효과를 비교해보자.
    - SCRIPT LOAD 명령어를 실행하려면 노드에 키가 저장되어 있어야 하여, 스크립트를 클러스트 내 모든 노드에 캐싱해야 한다.
- 해시 태그
    - 서로 다른 해시 슬롯에 저장된 복수의 키를 받으면 스크립트를 실행할 수 없음
    - 해시 태그 : 키의 일부를 중괄호로 감싸면 해당 부분이 키의 태그로 인식되어, 같은 슬롯에 포함된다.
- 사용 용도
    - Atomic Processing
        - 여러 개의 명령을 묶어 하나의 명령어로 수행하도록 하여 Atomic한 처리를 보장
        - Pipeline은 atomicity를 보장하지 않아, 여러 개의 명령어를 Atomic하게 처리하려면 트랜젝션과 lua밖에 없다.
        - 레디스 클러스터 환경에서 클라이언트는 변경하려는 키의 노드 위치를 파악할 수 없다.
            - 이때 Lua script를 이용하면 명령어를 실행할 때 키를 명시적으로 부여받아서 서버측에서 노드 연산을 타겟 서버로 보낼 수 있다.
    - Cache stampede 대책
        - 동시 요청 수가 많은 상황에서 캐시가 소진되면 마스터 데이터에 IO, 어플단의 캐시 재연산용 리소스에 큰 부하가 걸릴 수 있다.
            - Probablistic Early Recomputation은 이를 막기 위한 방법 중 하나다.
        - 캐시 엔트리의 유효 기간이 만료되기 전 일정 확률로 캐시를 재연산한다.
        - lua 스크립트로 레디스에서 이를 구현할 수 있다.
