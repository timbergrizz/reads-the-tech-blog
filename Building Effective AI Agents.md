- 출처 : [Building Effective AI Agents](https://www.anthropic.com/engineering/building-effective-agents)
- 모델의 가장 성공적인 구현은 복잡한 프레임워크가 아닌, 단순한 모델과 툴로 구성되는 경우가 많음
- What are agents?
	- 에이전트는 여러 방법으로 정의될 수 있고, Anthropic에서는 다음과 같이 정의한다.
		- Workflow: LLM과 툴이 기존에 정의된 코드로 오케스트레이트되는 시스템
		- Agent: LLM이 동적으로 프로세스와 툴을 사용할 수 있고, 태스크에 대한 전반적인 컨트롤을 가지는 시스템
- When (and when not) to use agents
	- LLM과 어플리케이션을 구성할 때, 가장 단순한 솔루션을 찾는 것을 추천한다.
		- 복잡한 구조는 필요한 경우에만 추가해야 한다.
	- 에이전틱 시스템은 태스크 퍼포먼스와 레이턴시, 비용을 트레이드오프하고, 여기에 대해 충분히 고려해야 한다.
	- 복잡한 작업이 필요한 경우, 잘 정의된 태스크에 대해 워크플로우가 예측 가능성과 일관성을 제공한다.
		- 에이전트는 대규모에서 유연성과 모델이 주도하는 의사 결정으로 할 수 있다.
		- 그러나 대부분의 어플리케이션에서 retrieval과 예시 제공하면 보통 충분하다.
- When and how to use frameworks
	- 에이전트 시스템을 구현하기 쉽도록 하는 LangGraph같은 프레임워크들이 있다.
	- 이러한 프레임워크들은 로우 레벨 작업들을 간단한 표준으로 제공하여, 구성을 쉽도록 한다.
		- LLM 호출, 툴 정의 및 파싱, 콜 체이닝 같은 것
	- 하지만, 프롬프트와 응답을 숨기는 추가적인 추상화 레이어를 만들어서 디버깅하기 어려워진다.
	- 단순한 시스템에서 해결 가능한 문제를 복잡한 시스템으로 만들도록 유혹한다.
	- 일단은 LLM API를 사용하는 것으로 시작해도 충분하다.
		- 많은 패턴들이 그냥 코드로 구현 가능하다.
	- 프레임워크를 사용한다면, 추상화 아래에 어떤 코드가 동작하는지 이해해야 한다.
		- 잘못된 추측이 보통은 고객 에러의 가장 큰 원인이다.
	- Anthropic의 [Cookbook](https://github.com/anthropics/anthropic-cookbook/tree/main/patterns/agents)을 참고하자.
- Building blocks, workflows, and agents
	- 프로덕션 레벨에서 자주 사용하는 에이전틱 시스템의 패턴
		- 파운데이션 블락인 augmented LLM부터, 복잡성을 늘려 워크플로우와 자동 에이전트까지
	- Building Block: The augmented LLM
		- ![d3090d3f40bb2b6f477901cc9a240738d3dd1371-2401x1000.webp](../assets/d3083d3f40bb2b6f477901cc9a240738d3dd1371-2401x1000_1752204490445_0.webp)
		- 에이전틱 시스템의 가장 기본적인 블락이다.
			- Retrievial, tools, memory같은 augmentation으로 LLM을 강화한 구조이다.
		- 현재 모델들은 이러한 augmentation 능력을 동적으로 사용할 수 있다.
			- 검색 쿼리를 만들어 검색하고, 적절한 툴을 선택하고, 어떤 정보를 저장할지를 직접 결정한다.
		- 구현을 위한 2개의 핵심이 있다.
			- 특정한 유즈 케이스에 대해 어떤 능력이 필요한지 정리한다
			- 모델에 문서화가 잘 된 인터페이스를 제공한다
		- augmentation 구현엔 방법들이 있긴 한데, MCP 우리가 만든거 좋으니까 써라
	- Workflow: Prompt chaining
		- ![7418725e3dab222dccb379b8879e1dc08ad34c78-2401x1000.webp](../assets/7418719e3dab222dccb379b8879e1dc08ad34c78-2401x1000_1752204477048_0.webp)
		- 태스크를 여러 개의 단계로 쪼개고, 각각의 LLM 콜이 단계들을 수행하도록 한다.
			- 중간 단계들을 코드레벨에서 체크하도록 할 수 있다.
		- 여러 개의 서브 태스크로 나눌 수 있는 시스템에서 적절하다.
		- 목표는 LLM이 비교적 쉬운 태스크를 수행하도록 하여 레이턴시와 정확도를 trade-off 하는 것
		- 다음과 같은 예시가 있다.
			- 마케팅 카피를 만들고, 다른 언어로 번역하는 프로세스
			- 도큐먼트의 아웃라인을 만들고, 아웃라인이 특정 주제를 만족하는지 확인 후, 아웃라인에 기반하여 문서를 작성하는 프로세스
	- Workflow: Routing
		- ![11c0c0e9fe4def0b584c04d37849941da55e5e71c-2401x1000.webp](../assets/5c0c0e9fe4def0b584c04d37849941da55e5e71c-2401x1000_1752204458308_0.webp)
		- Routing은 입력을 분류하고, 분류한 입력을 여러 개의 전문화되어 구현된 팔로우업 LLM으로 보낸다.
		- 관심사 분리가 가능해지고, LLM을 전문화된 프롬프트로 분리하여 사용할 수 있다.
			- 관심사 분리가 안되면 하나의 입력에 대한 최적화는 다른 입력의 퍼포먼스에 영향을 미친다.
		- 카테고리가 나뉘어져서 따로 처리하는게 좋은 입력들이 들어오는 복잡한 태스크에 대해 유용하다.
			- LLM이 분류를 정확하게 할 수 있으면 좋다.
			- 여러 종류의 고객 지원에 대한 질문을 분류하여 처리하도록 할때
			- 질문의 난이도를 분석하여 쉬운 질문은 작은 모델, 어려운 질문은 큰 모델로 보내도록 할 때
	- Workflow: Parallelization
		- ![412bb032ca007fd1624f261af717d70e6ca86286-2401x1000.webp](../assets/406bb032ca007fd1624f261af717d70e6ca86286-2401x1000_1752204442847_0.webp)
		- LLM이 동시에 태스크에 대해 출력을 생성하고, 생성한 출력을 통합하는 방법이 있다.
		- 2가지 경우에 이 워크플로우를 사용할 수 있다.
			- Sectioning: 태스크를 여러 개의 서브태스크로 나누고 서브태스크들을 병렬적으로 수행한다.
			- Voting: 동일한 태스크를 여러번 돌려 다양한 결과 값을 통합하도록 한다.
		- 서브태스크를 분리하고, 이를 동시에 수행해서 빠르게 수행하도록 할 때 유용하다.
			- 여러 고려가 필요한 복잡한 태스크가 있을 때, 이를 분리된 모델 콜로 보내어 각각의 특정한 컨택스트를 보도록 할때도 유용하다
			- Sectioning
				- 유저 쿼리를 수행하는 동안, 부적절한 요청을 가리는 가드레일을 구현하는 경우
				- 콜마다 다른 퍼포먼스가 나올 때 LLM 성능을 측정하기 위해 자동화를 하는 경우
			- Voting
				- 코드 조각의 취약점을 리뷰하는 경우 여러 관점을 다른 프롬프트로 나누어 수행하도록 한다
				- 주어진 컨텐츠 내용의 적절성을 여러 관점으로 나누어 평가하거나 동일한 관점으로 threshold를 만들어 비교하도록 할때
	- Workflow: Orchestrator-workers
	  id:: 687450b7-275e-4ac6-8f7e-52eeaee5e530
		- ![8991fc683fae4780fb34eab1365ab78c7e51bc8e-2401x1000.webp](../assets/8985fc683fae4780fb34eab1365ab78c7e51bc8e-2401x1000_1752204423855_0.webp)
		- 중앙 모델이 태스크를 분리하고, 워커 LLM에게 할당한 후 워커 결과로 응답을 생성
		- 어떤 서브태스크가 필요한지 예측하기 어려운 복잡한 태스크에서 유용하다.
			- 구조적으로 유사하지만, 유연하게 병렬화를 수행한다는 점이 다름.
			- 복잡한 변경을 하거나 많은 파일을 변경하는 코드 프로덕트 생성
			- 여러 개의 소스에서 탐색한 정보를 모아 분석하여 가장 관련성 높은 정보를 추출할 때
	- Workflow: Evaluator-optimizer
		- ![18f51e6406ccb29e695da48b17017e899a6119c7-2401x1000.webp](../assets/14f51e6406ccb29e695da48b17017e899a6119c7-2401x1000_1752204402717_0.webp)
		- 하나의 LLM이 응답을 생성하고, 다른 하나가 평가와 피드백을 제공한다.
		- 평가 기준이 명확하고, 반복적인 강화가 정량적인 값을 제공할 때 유용하다
			- LLM이 피드백을 제공할 수 있고, 인간이 피드백을 제공 ![8989fc683fae4780fb34eab1365ab78c7e51bc8e-2401x1000.webp](../assets/8985fc683fae4780fb34eab1365ab78c7e51bc8e-2401x1000_1752204417674_0.webp) 할 때 성능이 향상되면 잘 맞는다.
				- 정돈된 문서를 작성할 때 인간 작성자에게 피드백을 제공하는 것과 유사하다.
			- 문학 번역의 경우 번역 LLM이 잡지 못한걸 평가자가 피드백 하도록 할 수 있다.
			- 여러 라운드로 구성된 검색 태스크에 대해서 다음 라운드에 어떤 것을 검색할지 피드백 할 수 있다.
	- Agents
		- ![62d9f10c985c4eb5d53798dea315f7bb5ab6249e-2401x1000.webp](../assets/58d9f10c985c4eb5d53798dea315f7bb5ab6249e-2401x1000_1752204386629_0.webp)
		- 복잡한 입력을 받아, 사고와 계획에 참여하고, 신뢰 가능한 방법으로 툴을 사용하고, 에러에서 회복ㅎ라는 프로덕션 레벨에서의 LLM의 성숙한 형태이다.
		- 사람의 명령이나 상호작용 토론으로 작업을 시작한다.
			- 태스크가 명확하면, 에이전트는 독립적으로 계획을 세우고 동작하여 높은 확률로 사람에게 정보와 판단을 제공한다.
		- 실행 도중 각 단계에서 에이전트가 환경으로부터 기반 지식을 얻는 것이 진행 사항 평가에 있어 중요하다.
			- 에이전트는 이를 통해 체크포인트에서 사람의 피드백을 기다리거나, 블로커를 만났을 때 멈출 수 있다.
			- 태스크는 보통 완료될 대 종료되는데, 컨트롤을 유지하기 위한 종료 조건을 만드는 것도 필요하다.
		- 에이전트는 복잡한 태스크를 다룰 수 있지만, 구현은 보통 직관적이다.
			- 환경에 대한 피드백이 루프에 기반하고, 툴을 사용할 수 있는 LLM이 일반적이다.
				- 툴셋을 잘 디자인하고 깔끔하고 숙고하여 문서화하는 것이 중요하다.
		- 에이전트는 어렵고 복잡하며 단계의 개수를 예측할 수 없고, 고정된 흐름으로 설계할 수 없으며 열린결말인 문제들에 사용될 수 있다.
			- LLM이 여러 턴동안 돌고, LLM의 의사 결정의 어느정도의 신뢰 레벨이 있어야 한다.
			- 에이전트의 자동화에는 높은 비용과 에러로 이어질 수 있어, 샌드박스 환경에서 충분한 테스트와 가드레일 세팅을 추천한다.
			- SWE-bench 테스트를 위한 에이전트
			- [Computer use 레퍼런스](https://github.com/anthropics/anthropic-quickstarts/tree/main/computer-use-demo) 구현 보시죠
- Combining and customizing these patterns
	- 이러한 빌딩 블락은 일반적인 패턴이고, 개발자가 유즈케이스에 맞춰 원하는 형태로 결합하고 구성할 수 있다.
	- 성능을 측정하고 구현에 대해 반복하는 것이 중요하다.
	- 결과가 개선될 때만 복잡성을 추가하세요!!!!!!!
- Summary
	- LLM에서 성공은 복잡한 시스템을 만드는 문제가 아니라, 필요에 맞는 적절한 시스템을 만드는것이 핵심
	- 단순한 프롬프트로 시작해서 평가로 최적화하고, 단순한 방법이 안될때만 멀티 스텝을 고려하세요
	- 에이전트를 구현할 때의 3개의 코어 원칙
		- 에이전트 디자인에 있어, 단순성을 유지한다
		  logseq.order-list-type:: number
		- 에이전트에게 계획 단계을 명시적으로 보여주어 투명성을 확보한다
		  logseq.order-list-type:: number
		- 툴에 대한 문서화와 테스트로 에이전트와 컴퓨터의 인터페이스를 신중하게 설계한다.
		  logseq.order-list-type:: number
	- 프레임워크는 빠르게 시작할 수 있게 하지만, 추상화 레이어를 줄이고 기본적인 구성 요소로만 가는것도 중요하다.
- Appendix 1 : Agents in practice
	- 상기한 패턴들의 실용적인 사용 예제
	- Customer support
		- 고객 지원 챗봇은 일반적인 챗봇 인터페이스와 추가적인 툴 통합을 필요로 했다.
		- 다음과 같은 이유로 open-ended agents로 구현했다
			- 외부 정보에 접근 할 수 있으면서, 대화의 흐름을 자연스럽게 따라가는 상호 작용을 해야한다
			- 고객 정보, 주문 정보, 지식 기반에 통합되는 툴이 필요하다
			- 환불 신청, 티켓 업데이트 등이 프로그램으로 수행될 수 있어야 한다.
			- 유저가 정의한 방법으로 문제가 해결될 수 있어야 한다.
		- 이러한 접근으로 성공적인 구현을 하여, 성공한 응답에 대해서만 비용을 청구할 정도로 자신감 있는 시스템을 구축할 수 있었다.
	- Coding agents
		- 소프트웨어 개발은 자동화된 문제 해결과 코드 완성으로 LLM의 중요한 가능성을 보여준다.
		- 다음과 같은 이유로 Agent가 효율적이다.
			- 자동화된 테스트를 코드가 통과할 수 있어야 한다.
			- 에이전트가 테스트 결과를 피드백 결과로 반복 수행할 수 있어야 한다.
			- 문제가 잘 정의되어 있으며 구조적이다
			- 결과 퀄리티가 객관적으로 측정될 수 있따.
		- 에이전트가 이제 깃허브 이슈를 단독으로 처리할 수 있어졌다.
		- 자동화된 테스트가 잘 작동하는지 확인할 수 있지만, 시스템의 요구사항을 충족하는지 인간의 리뷰는 여전히 중요하다.
- Appendix 2: Prompt engineering your tools
	- 어떤 에이전틱 시스템을 구성하든, 툴이 가장 중요한 구성 요소이다.
		- 툴로 LLM이 외부 서비스와 API에 접근할 수 있도록 한다.
		- 툴의 정의와 스펙이 프롬프트 엔지니어링만큼의 주의가 들어가야 한다.
	- 같은 액션을 특정하는 여러 방법이 있지만, 모델에게 불리한 방법과 유리한 방법이 있을 수 있다.
		- 툴의 포맷을 결정할 때 다음과 같은 방법을 사용하는 것을 권장한다.
			- 모델에게 코너로 가기 전, 생각할 충분한 토큰을 준다
			- 인터넷의 글에서 자연스럽게 발생하는 것과 유사하도록 포맷을 구성하낟.
			- 포맷에 있어 오버헤드가 없도록 구성한다.
				- 수천개의 코드를 유지하거나, 작성하는 코드를 escaping하는거 말고
	- 인간과 컴퓨터의 인터페이스에서 어느정도의 노력이 필요한지 생각해보고, 에이전트와 컴퓨터가 잘 통신할 수 있도록 그만큼의 노력을 들이는 것이다.
		- 내가 모델의 입장이 되어 세부 사항과 파라미터로 이 툴을 사용할 수 있는지를 평가한다.
			- 좋은 툴은 예시 사용과 엣지 케이스, 입력 포맷 요구사항을 제공하며 다른 툴과의 경계가 명확하다
		- 파라미터 이름과 설명을 어떻게 하면 더 명확하게 작성할 수 있는지를 생각해보자
		- 모델이 어떻게 툴을 사용하는지를 생각해보고, 최대한 많은 예시 입력을 넣어 모델이 어떤 실수를 만드는지 살펴보자.
		- argument를 수정하여 실수를 만들기 어렵도록 구성하자. (Poka-yoke)