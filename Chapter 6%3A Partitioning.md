- Intro
	- Replication은 같은 데이터를 여러개 갖고 있는 것, Partiitioning은 데이터 자체를 쪼개는 것
	- 파티션은 모든 데이터를 딱 하나의 파티션으로 할당되며, 각각의 파티션은 DB의 작은 부분이 된다.
	- 확장 가능성때문에 파티셔닝을 고려하게 된다.
		- 다른 파티션은 shared-nothing 클러스터에서 다른 노드에 할당될 수 있다.
	- 파티션 하나 타는 쿼리는 각각의 노드가 갖고있는 파티션으로 독립적으로 실행할 수 있다.
	- 크고 복잡한 쿼리는 여러 노드에서 병렬 처리로 실행될 수 있다.
- Partitioning and Replication
	- 파티션은 일반적으로 레플리케이션과 조합되어 사용된다.
		- 파티션 단위로 복제가 되고, 따라서 하나의 파티션에만 있어도 여러 노드에 분산되어 저장되며 장애 저항성을 가진다.
		- 노드는 한 개 이상의 파티션을 저장하고, 파티션의 리더를 하나의 노드에 저장하는 방식이 사용될 수 있다.
			- Replication에서 논의된 내용이 파티션 복제에서도 동일하게 적용된다.
- Partitioning of Key-Value Data
	- 파티션의 목적은 데이터의 쿼리 로드를 노드 사이에 이븐하게 분배하는것
		- 파티셔닝이 페어하지 않으면 skewed됐다고 하고, 비효율적인 결과로 이어짐
			- 극단적으로 모든 로드가 하나의 파티션으로 몰릴수도 있다.
	- 적절하지 않게 많은 로드를 받는 파티션을 핫스팟이라고 한다.
		- 가장 간단하게 이를 피하는 방법은 랜덤하게 레코드를 파티션에 나누는 것이다.
			- 노드 사이에 균일하게 나눌수 있지만, 어떤 노드에 데이터가 있는지 모르니 모든 노드에 쿼리가 가야한다.
	- Partitioning by Key-Range
		- 백과사전처럼 연속적인 범위의 키를 각 파티션으로 분할할 수 있다.
			- 파티션이 갖는 range들의 경계선을 알면 어떤 파티션이 어떤 키를 갖는지 알 수 있다.
			- 어떤 파티션이 어떤 노드에 있는지 알면 적절한 노드로 요청을 보낼 수 있다.
		- 데이터가 이븐하게 분포되어있지 않을수 있기 때문에 key의 range가 even할 필요는 없다
		- 파티션 경계는 관리자가 수동으로 결정할 수도 있고, DB가 자동으로 선택할 수도 있다.
		- 장점 : 각 파티션에서 데이터를 정렬해서 저장하고 따라서 range 쿼리가 쉬워진다.
		- 단점 : 특정 접근 패턴이 핫스팟이 될수가 있어, 파티션 키를 잘 결정해야 한다.
	- Partitioning by Hash of Key
		- 많은 분산 DB는 해쉬함수로 파티션을 결정한다.
			- 좋은 해쉬함수는 skewed된 데이터를 가져가서 이븐하게 분배한다.
			- 입력 스트링이 유사하더라도, 해쉬는 범위 내에서 이븐하게 분포되어야 한다.
		- 파티셔닝을 위해서는 암호학적으로 강한 해쉬가 필요하진 않다.
		- 적절한 해쉬 함수가 있으면 각 파티션을 해쉬의 범위로 설정할 수 있다.
			- 모든 키는 해쉬 함수 거친 후 범위에 맞는 파티션으로 삽입된다.
			- 파티션 간에 키를 분배하는데 적절하다.
				- 파티션 바운더리는 이븐하게 위차할 수 있고, 랜덤으로 선택될 수도 있다.
		- Consistent Hashing : 인터넷 사이에서 로드를 분배하기 위한 방법.
		- 해쉬 기반으로 파티셔닝을 하면 효율적으로 레인지 쿼리를 쓰기 어렵다.
			- adjacent한 키들이 파티션으로 흩어져 정렬된 순서가 소실된다.
			- 여러 개의 컬럼을 결합하여 키를 만드는 전략이 있다.
		- 여러 컬럼을 조함한 concatenated index 전략을 사용하여 서로 다른 파티션에 저장되더라도 시간 기준으로 정렬하도록 할 수 있다.
	- Skewed Workloads and Relieving Hot Spots
		- 파티션 위치를 결정하기 위해 키를 해싱하는건 핫스팟은 줄이지만 완전히 피할수는 없다.
			- 극단적인 경우에는 같은 키에 대해서 모든게 발생할 수도 있다.
		- 대부분의 현대 데이터 시스템은 자동으로 skewed된 워크로드를 없앨 수 없어, 어플리케이션 단에서 줄여야 한다.
			- 키 하나가 요청이 많으면, 키에 랜덤 넘버를 추가하는 것도 방법이다.
		- 서로 다른 키에 쓰기를 분리하면, 모든 읽기는 모든 키를 읽어서 결합하는 추가적인 작업을 해야 한다
			- 이 테크닉도 추가적인 bookkeeping을 유발한다.
- Partitioning and Secondary Indexes
	- 세컨더리 인덱스가 생기는 경우 파티셔닝이 더 복잡해진다.
		- 키밸류스토어에서는 복잡해서 구현하지 않는 경우도 있지만, 구현하는 경우도 있다.
		- 문제는 파티션에 완전히 매핑되지 않는다는 점이다.
	- 세컨더리 인덱스를 파티셔닝하는 2가지 방법이 있다.
		- Partitiong Secondary Indexes by Document
			- 각 파티션은 완전히 분리되어 있고, 각 파티션이 각자의 세컨더리 인덱스를 갖고 있다.
			- 데이터를 작성할 때, 도큐먼트 ID만 확인한다.
			- 도큐먼트 ID에 특별한 무언가를 하지 않으면, 각각에 파티션의 인덱스에 따로 배치되는 이유를 찾을 수 없다.
				- 모든 파티션에 요청을 날려야한다.
				- scatter. gather라는 분산DB 쿼리 전략이 있고, 이때 모든 파티션에 대해 쿼리를 날린 후 모아야 해서 세컨더리 인덱스가 비싸진다.
			- 문제가 있어도 자주 쓰인다.
		- Partitioning Secondary Indexes by Term
			- 각 파티션이 각자의 세컨더리 인덱스를 갖는것보다, 모든 파티션을 커버하는 글로벌 인덱스를 구축할 수 있다.
				- 하나의 노드에 저장하는 것이 아닌, 글로벌 인덱스 자체를 파티션하여 여러 노드로 나누어 저장하는 것
				- 이를 term-partitioned 인덱스라고 한다.
			- document-partitioned index 와 비교
				- 모든 파티션에 대해 읽기를 하지 않아 읽기가 효율적이다.
				- 쓰기가 여러 파티션의 인덱스로 적용되기 때문에 느리고 복잡하다.
			- 이상적으로는 인덱스가 모두 최신이 되어야 하고, 쓰기가 발생한 모든 데이터가 인덱스가 반영되어야 한데, term-partition index에는 이게 어렵다.
				- 글로벌 세컨더리 인덱스는 일반적으로 비동기적으로 이루어진다.
- Rebalancing Partition
	- 어떤 파티셔닝 스키마를 사용하더라도 리밸런싱은 다음과 같은 조건을 만족해야 한다.
		- 리밸런싱 후에 로드 (요청, 데이터 양)이 클러스터간에 적절히 분배되어야 한다.
		- 리밸런싱이 발생하는동안에도 읽기 쓰기가 처리될 수 있어야 한다.
		- 필요를 제외한 데이터는 노드간에 이동이 발생하지 않아야 한다.
	- Strategies for Rebalancing
		- How not to do it: hash mod N
			- 가장 좋은것은 해시를 범위로 나누고 파티션을 해쉬로 나누는 것.
			- 노드 개수인 N이 바뀔때 복잡해지고, 리밸런싱의 비용이 커진다.
				- 필요 이상으로 데이터를 옮기지 않도록 구성한다.
		- Fixed number of partitions
			- 노드보다 많은 파티션을 만들고, 각 노드마다 여러 개의 파티션을 할당한다.
			- 이제 노드가 추가되면, 새로운 노드는 존재하는 노드에서 파티션을 훔쳐오기만 하면 된다.
			- 파티션 개수는 변하지 않으며, 파티션이 어떤 노드에 할당되는지만 달라진다
			- 이러한 세팅은 처음 DB세팅할때 파티션 개수 설정하고 안바꾼다.
				- 다시 합치거나 나눌 수는 있긴 한데, 고정된 넘버가 관리가 용이하다.
			- 적절한 파티션 개수는 데이터셋 사이즈가 달라 결정이 어렵다.
				- 각 파티션이 총 데이터의 고정된 크기만큼을 가지면 각 파티션의 사이즈가 계속 증가하게 된다.
				- 파티션이 너무 많으면 노드 에러에서 리밸런싱이나 복구가 어려워진다.
				- 가장 적절한것은 그냥 너무 크지도 작지도 않은 적절한 사이즈.
		- Dynamic partitioning
			- key-range partition db는 파티션을 동적으로 생성한다.
				- 파티션이 설정된 사이즈보다 커지면 두개의 파티션으로 분리되고, 반대로 일정 사이즈보다 작아지면 합쳐진다.
				- B트리와 유사하게 동작한다.
			- 데이터 양에 맞추어 파티션 개수가 설정되는 장점이 있다.
			- 최초에 하나의 파티션으로 생성되어 하나의 노드에서만 동작한다는 단점이 있다.
				- 따라서 최초 파티션 개수를 세팅하도록 한다.
			- hash-partitioned data에도 적절하다.
		- Partitioning proportionally to nodes
			- 동적 파티셔닝의 파티션의 개수는 데이터셋에 사이즈로 결정된다.
			- 정적 파티셔닝은 파티션의 사이즈가 데이터셋으로 결정된다.
			- 세번째 옵션으로, 파티션의 개수를 노드의 개수와 맞추는 방법도 있다.
			- 클러스터에 노드개수가 증가하면 파티션 개수가 증가하고, 노드 개수가 감소하면 파티션 개수도 감소한다.
				- 새로운 노드가 클러스터에 들어오면 존재하는 파티션 중 쪼갤 파티션을 선택하고 가져간다.
- Operations: Automatic or Manual Rebalancing
	- 리밸런싱을 완전 자동으로 돌릴수도, 완전 수동으로 돌릴수도 있다.
		- 자동으로 돌리면 추가적인 작업 없이 수행할 수 있어 편하긴 한데, 예측 불가능해진다.
			- 리밸런싱은 비용이 큰 작업이라 주의 깊게 수행되지 않으면 문제가 발생한다.
			- automatic failure detection과 같이 작동했을때 노드가 죽었다고 판단하면 클러스터에서 노드를 제거해버리고, 연쇄적인 문제로 이어질 수 있다.
	- 인간이 어느정도는 개입하는것이 필요하다.
- Request Routing
	- 클라이언트가 요청 날릴때, 어디로 연결할지 어떻게 알 수 있을까?
	- 하이레벨에서 다음과 같은 접근 방식이 있다.
		- 클라이언트가 어떤 노드로든 연결할 수 있도록 하고, 노드에서 라우팅을 하도록 한다.
		  logseq.order-list-type:: number
		- 라우팅 티어로 요청을 보내도록 한다.
		  logseq.order-list-type:: number
		- 클라이언트가 파티션에 대한 정보를 갖고 있도록 하고, 바로 라우팅 하도록 한다.
		  logseq.order-list-type:: number
		- 모든 경우, 변경사항이 발생했을 때 컴포넌트에 대한 라우팅 결정에 어떻게 반영할 것인가가 된다.
			- 모든 참여자가 동의하는 방법을 필요로 하고, 아니면 잘못된 노드로 가 정상적으로 핸들링이 안된다.
	- 일반적인 분산 시스템에선 주키퍼같은 코디네이션 서비스로 클러스터 메타데이터를 관리한다.
		- 주키퍼가 클러스터의 메타데이터를 트래킹한다.
		- 주키퍼는 파티션의 메타데이터를 저장하고, 다른 액터가 주키퍼에서 데이터를 받아온다.
		- 파티션 데이터가 변경되거나 노드가 추가, 제거되면 주키퍼가 라우팅 티어로 이를 알린다.
	- 카산드라, Riak은 노드 간에 gossip protocol을 사용해 클러스터 상태 변화를 감지한다.
		- 요청은 어떤 노드로든 전송될 수 있고, 노드가 적절한 노드로 라우팅을 한다.
	- Couchbase는 자동으로 리밸런싱 하지 않아 디자인을 단순화한다.
	- 라우팅 티어나 랜덤 노드로 쏠때 DNS를 쓴다.
- Parallel Query Execution
	- 병렬로 대규모의 쿼리를 전송해야 하는 경우도 발생할 수 있다.