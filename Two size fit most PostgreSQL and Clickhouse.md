---
출처: '[Two sizes fit most: PostgreSQL and Clickhouse](https://about.gitlab.com/blog/two-sizes-fit-most-postgresql-and-clickhouse/)'
---

- 시스템R이 등장한 74년 이후로 관계형 DB와 SQL DB가 데이터 영속성을 위한 산업의 지배적인 접근 방법이 되었고 지금까지 유지했다.

  - RDB의 자리를 위협하는 존재도 있었지만, PostgreSQL이 과거로부터 계승한 아키텍처를 개선했다.

  - 오픈소스 MySQL은 LAMP 스택에 포함되어 초기 웹 개발을 지배했다.

- 이러한 트랜드의 예외는 OLAP에 있다.

  - 특수한 테크닉이 특정 워크로드를 크게 향상시키고, 이게 유즈케이스에 부합하는 경우가 있다.

  - Clickhouse같은 새로운 경쟁자가 분석에 대해 크게 다른 접근을 가능하게 했다.

- 기술이 지배적이게 되면, 적절하지 않아도 아무 생각 없이 적용하게 되고, 이렇게 되면서 모든 종류의 데이터가 일반 목적의 관계형 DB로 들어가게 된다.

  - 극단적인 예시로 개발자가 5개의 작은 데이터 조각을 저장하려고 원격 데이터베이스를 만들거나, 애플처럼 시스템 로그를 SQLite로 때려박는 경우가 있다.

- 2005년 DB 연구원 Ingres와 PostgreSQL을 개발한 마이클 스톤브레이커는 `One Size Fits All: An Idea Whose Time has Come and Gone`라는 논문을 발표했다.

  - One size fits all이란 개념이 오래 지나치게 확대되었다고 주장했으며, 벤치마크로 이를 뒷받침했다.

  - DB의 핵심 어플리케이션인 OLTP 외에도 많은 워크로드가 있고, 이를 다 다루기엔 일반 목적 데이터베이스 아키텍처가 충분히 훌륭하지 않았다

  - RDB나 SQL이 잘못된게 아니라, 시스템R과 Ingres에서 계승된 특수한 아키텍처가 문제라는 뜻이다.

    - 다음과 같은 특징을 가진다.

      - 디스크와 행 기반 스토리지와 인덱스 구조

      - 레이턴시를 숨기기 위한 멀티 쓰레딩

      - 락 기반의 동시성 관리 매커니즘

      - 로그 기반 복구 시스템

  - 전통적인 아키텍처가 적절하지 않다고 여겨지는 주 유즈 케이스는 특수 목적 텍스트 인덱스에 추가로 데이터 웨어하우스가 있다.

    - 컬럼 기반 스토리지가 전통 스토리지보다 10~100배 더 효율적이다.

- OLAP DB 엔진이 메인스트림 DB에서 분리될 것이라는 예측은 산업계에서 실현되었다.

  - OLAP DB는 이제 중요한 카테고리가 되었다.

  - 분석 목적을 위한 실용적인 장점은 분리된 데이터 엔진을 갖는게 보장될 정도로 컸다.

    - 필수적인 경우도 있다.

    - Clickhouse 개발자들은 실시간 분석을 커스텀 데이터 구조 없이 일반적인 SQL 쿼리로 수행하고자 했다.

      - 과거에는 범용 DB 엔진으로 불가능하다고 여겨졌고, 실제로 불가능해 주로 커스텀 데이터 구조를 사용했다.

      - 주로 그렇듯이 불가능하다는 사실이 많은 연구와 기발한 엔지니어링으로 가능해졌고, 일반화된 SQL로 쿼리할 수 있는 실시간 분석 OLAP 최적화 DB 엔진을 만들었다.

- 2005년 논문은 OLTP를 전통적 아키텍처가 적용되는 부분에만 남겨두었다.

  - 2년 뒤 `The end of the Architectural Era (It's time for a Complete Rewrite)`를 발간했다.

    - OLTP에도 과거 엔진보다 10배 이상 빨라질 수 있다고 주장했다.

  - 컴포넌트들에 대한 상대적 성능에 대한 예측이 정확하지 않다는게 핵심이었다.

    - 엔진이 사용하는 시간의 90%가 실제 쿼리 처리가 아닌 버퍼관리, 락 같은 오버헤드에 사용되었다

    - 이러한 오버헤드를 없앤다면 DB 엔진을 10배 빠르게 만들 수 있을 거라는 기대였다.

      - 이 목표를 달성하기 위해 단일 스레드로 메인 메모리에서 처리하는 DB 엔진을 필요로 했다.

        - 과거의 아키텍처와는 급진적으로 다른 출발이었다.

  - 2000년대 초기 야후는 2GB 미만의 데이터셋은 디스크가 아니라 램에 있도록 했다.

    - EventPoster 아키텍처, In-Process REST, LMAX 패턴 등 다른 영역의 아이디어와 유사했다.

    - 복잡한 멀티 스레딩과 디스크 기반 시스템 기반에서 싱글스레드 램 기반 아키텍처로 단순성, 신뢰성, 성능의 큰 향상을 얻을 수 있었다.

    - 32비트 컴퓨팅의 과거였고, 지금 우리는 10테라 단위로 램을 확보할 수 있다.

      - 램에 저장할 수 있는 워크로드의 양이 커졌다.

  - 스톤브레이커 팀은 학술 프로토타입 H-Store와 상용 제품 VoltDB를 출시했다.

    - 놀랍게도 의도한대로 작동했으며, 약속한 내용을 지킬 수 있었다.

    - 이러한 약속들에 트레이드오프가 있었고, 대부분에 도메인에서 이상적이지 않았다.

      - 전체 DB를 RAM에 저장하는 것은 이제 가능하지만, 접근 빈도가 낮은 콜드 데이터가 대부분일 경우 비용 효율적이지 않다.

      - 피크 성능은 좋았지만, 컴퓨터가 빨라져 그정도로 빠른 속도가 특수한 도메인에서 필요했다.

      - 성능이 충분히 좋아지자 사람들은 최고 성능에서 최악의 경우의 레이턴시와 처리량에 집중이 옮겨졌다.

        - 단일 스레드만 접근하면서, 쿼리가 길어지면 모든 DB를 멈추고, 엄청나게 나쁜 테일엔드 성능이 보인다.

      - 분산 세팅을 필요로 해, 엔트리 레벨 세팅에 진입 장벽을 높였다.

    - 전통적인 OLTP 아키텍처의 시대가 종료되지 않은 것처럼 보였다.

- 스톤브레이커의 또 다른 아이디어인 PostgreSQL이 주요 상용 DB 벤더에 대한 지배적인 대안이 되었다.

  - 메이저 DB 벤더사들이 제공하지 않는 것중에서 최고이다.

- GitLab은 2019년 MySQL에서 마이그레이션하여 PG를 레플리케이션과 함께 사용한다.

  - 중요한 기능들이 있었고, 대부분의 고객이 사용했기 때문이다.

  - NoSQL이 잠시 주도적인 DB가 되었었지만, 기술적인 처방은 특수한 상황에서만 작동했다.

    - NoSQL은 단일 카테고리라기보다, PostgreSQL이 기능이 풍부한 것만큼이나 그 안에 포함된 DB 엔진들이 매우 다양한 집합체이다.

- 컴퓨팅 성능과 빠른 스토리지가 증가하면서, 큰 볼륨과 트랜젝션 레이트는 전통적인 엔진으로 다룰 수 있게 되었다..

  - 전통적이지 않은 엔진도 SQL을 인터페이스로 관계형 모델을 제공할 수 있다.

  - 관계형 모델이 필요 없고 키밸류로 충분한 경우도 있다. 아니면 JSON 스토리지.

    - PostgreSQL의 JSON이 대부분의 유즈 케이스를 잘 다룬다.

    - 텍스트나 GIS같은 특수한 유즈케이스도 현대 관계형 DB 엔진이 잘 다룬다.
