---
type: Study
title: 'Chapter 7: Transactions'
tags: [Database, Data, 데이터중심어플리케이션설계]
출처: 데이터 중심 어플리케이션 설계
---

- 데이터 시스템에서 다음과 같이 다양한 부분들에 문제가 생길 수 있다.

    - DBMS나 하드웨어가 갑자기 죽을 수 있고, 그게 마침 쓰기 작업중일 때일수도 있다.

    - 어플리케이션의 크러쉬가 날 수 있고, 이것도 DB 오퍼레이션 연속 처리중인 때일 수 있다.

    - DB와 어플리케이션의 연결이나 DB 노드간 연결이 네트워크 Interruption이 발생해 끊어질 수 있다.

    - 여러 클라이언트가 동시에 쓰기 작업을 수행해, 동시에 서로의 변경 사항을 덮어쓰기 할 수 있다.

    - 클라이언트가 일부만 업데이트 되어 의미가 없는 데이터를 읽을 수도 있다.

    - 클라이언트간 Race Condition이 발생해서 생각도 못한 버그로 이어질 수도 있다.

- Reliable하기 위해서 시스템은 위의 fault에 대응하고 시스템 전반의 재앙으로 이어지지 않도록 해야 한다.

    - Transaction이 이러한 이슈를 대응하는 간단한 매커니즘으로 사용되었다.

- Transaction

    - 어플리케이션이 여러 개의 읽기, 쓰기를 하나의 논리적 단위로 그룹화하는 것이다.

    - 이론적으로 모든 읽기 - 쓰기를 하나의 오퍼레이션으로 실행한다.

    - 성공하면 모든 연산을 commit으로 반영하고, 실패하면 abort 또는 rollback으로 처리한다.

        - 실패했을 때 안전하게 다시 시도를 할 수 있고, 부분적 실패가 없어 에러 핸들링이 쉬워진다.

    - DB에 접근하는 어플리케이션의 단순화를 위한 프로그래밍 모델로 만들어진거고, 자연 법칙이 아니다.

        - 트랜젝션을 통해 가능한 에러 시나리오나 동시성 이슈를 DB가 알아서 처리할 수 있도록 한다.

    - 트랜젝션은 항상 필요하지는 않고, 트랜젝션의 보장을 줄이거나 없애는게 유리할 수 있다.

# The Slippery Concept of a Transaction

- 2000년대 후반 NoSQL은 새로운 데이터 모델을 제공하고, 복제와 파티셔닝을 기본으로 도입하며 인기를 얻었다.

- 트랜젝션은 확장성의 안티테제로 여겨졌고, 큰 스케일에서 성능과 가용성을 높이기 위해 트랜젝션을 버려야 한다고 생각했다.

    - 새로운 DB들은 트랜젝션을 제거하거나, 이전보다 더 적은 보장을 제공하도록 트랜젝션을 구성했다.

    - 반대로 "가치가 높은 데이터를 다루는 중요한 어플리케이션"에서 필수 요건으로 여겨졌다.

# The Meaning of ACID

- 트랜젝션이 보장은 안전성 보장은 ACID라는 약어로 알려져 있다.

    - Atomicity, Consistency, Isolation, Durability

    - 데이터베이스마다 구현이 다르고, "ACID 보장" 시스템이 어느정도로 보장되는지 확실치 않다.

## Atomicity

- 원자는 더 작은 파트로 나누어질 수 없다는 것을 의미한다.

    - 멀티 쓰레드 프로그래밍에서, 하나의 쓰레드가 atomic 연산을 실행하면, 다른 쓰레드는 이 연산 중간 결과값을 확인할 수 없다.

- ACID에서 atomicity는 클라이언트가 여러 쓰기를 진행할 때 처리 중간 fault가 발생하면 어떻게 처리할 것인가에 관해 다룬다.

    - 여러개의 쓰기가 하나의 atomic 트랜젝션으로 그룹화되고, 쓰기가 fault로 커밋되지 않으면 트랜젝션은 abort되고 DB는 트랜젝션중 진행한 모든 쓰기를 버리거나 undo 처리한다.

    - atomicity가 없으면 에러가 변경중에 바뀌면 어떤 데이터가 변경의 영향을 받았는지 파악하기 어렵다.

- 트랜젝션이 abort되어도 아무것도 변경되지 않아 클라이언트가 안전하게 다시 시도할 수 있다. 

## Consistency

- 하나의 단어가 너무 많은 뜻을 갖고 있다.

    - Replication에서도 사용되고, Rebalancing, CAP Theorem에도 사용되는데 여기도 사용된다.

- ACID에서 Consistency는 데이터에 대한 특정 statement가 항상 참이어야 한다는 것이다.

    - 트랜젝션이 이러한 불변성이 유효한 DB에서 시작되고, 모든 쓰기가 트랜젝션 중 유효성을 지킨다면 항상 불변성이 만족되는 것이 보장된다.

    - 어플리케이션의 불변성에 대한 개념에 의존하며, 어플리케이션이 트랜젝션을 적절히 정의해야 한다.

- 다른 속성과 다르게 Consistency는 어플리케이션의 영역에서 정의된다.

## Isolation

- 많은 DB는 동시에 여러 클라이언트로 접근을 허용하고, 동일한 DB 레코드에 접근한다면 동시성 문제로 이어질 수 있다.

- 격리는 동시에 실행된 트랜젝션들은 각각 독립되어 다른 트랜젝션에 영향을 끼치지 않는다는 것이다.

    - DB는 트랜젝션이 커밋될 때 동시에 실행되었어도 순차적으로 실행한 것과 동일한 결과여야 한다.

- 실제로 serializable 격리은 성능 문제로 거의 사용되지 않는다.

## Durability

- Durability는 트랜젝션이 성공적으로 커밋되면, 모든 데이터가 하드웨어 fault나 DB 크래쉬에도 소실되지 않는다는 것이다.

    - 단일 노드에서는 일반적으로 DB의 HDD, SDD같은 비휘발성 디스크로 작성된다는 것.

        - WAL 로그나 유사한 방법으로 디스크의 데이터 구조가 오염되어도 복구할 수 있도록 한다.

    - Replicated DB의 경우 여러 노드로 성공적으로 복제되었음을 의미한다.

- Durability를 제공하기 위해 DB는 commit 성공으로 처리할때 쓰기가 복제 완료까지 기다려야 한다.

- 완벽한 Durability는 존재하지 않는다. 한번에 하드 디스크랑 백업 다 날아가면 DB로 어떻게 할 수 없다.

### Replication and Durability

- 역사적으로 Durability는 archive tape로 작성하는 것으로 이해됐고, 이후에는 비휘발성 메모리로 작성되는 것을, 더 최근에는 mean replication에 채택되는 것을 의미한다.

- 어떤 구현이 나을까? 아무것도 완벽하지 않다.

    - 디스크에 작성하는 경우 컴퓨터가 죽으면 데이터는 소실되지 않지만 컴퓨터를 고치거나 디스크를 옮길때까지 접근 불가능하다.

        - Replicated 시스템은 노드 하나 죽어도 가용상태다.

    - 정전이나 특정 입력으로 인한 모든 노드의 크래쉬 같은 노드간 상호 연관된 fault는 한번에 모든 레플리카를 박살내서 메모리에만 있는 데이터는 모두 소실된다.

        - 디스크에만 작성했으면 남아있었다.

    - 비동기 replication 시스템에서, 리더가 죽으면 최근 발생한 쓰기는 소실될 수 있다.

    - 전원이 갑자기 나가면 SSD는 데이터가 소실될 수 있다. fsync도 적절하게 작동함을 보장할 수 없다.

    - 스토리지 엔진과 파일시스템 구현간의 많은 상호작용은 추적이 어려운 버그로 이어져, 크러쉬와 데이터 오염으로 이어질 수 있다.

    - 디스크 상의 데이터가 점진적으로 발견 전까지 오염되고, 레플리카와 최근 백업도 오염될 수 있다.

    - 30% ~ 80% 사이의 SSD는 4년동안 작동하면 적어도 하나의 bad block이 발생한다는 연구가 있다.

        - 하드디스크는 배드 섹터 확률은 낮지만, SSD보다 완전 박살날 확률이 높다.

    - SSD는 온도에 따라 전원 뽑으면 몇주 내로 데이터가 손실이 시작된다.

- 어떠한 방법도 완전한 보장을 할수가 없고, 리스크를 최소화하는 테크닉을 사용해야 한다.

# Single Object and Multi-Object Operations

- atomicity와 isolation은 클라이언트가 하나의 트랜젝션에서 여러번의 쓰기를 할 때 DB가 어떻게 동작해야 하는지를 정의한다.

    - Atomicity : 쓰기가 연속적으로 발생하는 도중 에러가 발생하면, 트랜젝션은 abort되어야 하며 지금까지 작성된 쓰기는 모두 discard한다.

    - Isolation : 동시에 실행되는 트랜젝션은 각각의 트랜젝션을 방해하지 않아야 한다.

        - 하나의 트랜젝션이 여러 쓰기를 작성할 때 다른 트랜젝션은 이런 쓰기를 읽지 않아야 한다.

    - 이 정의는 여러 객체를 한번에 수정하는 것을 가정한다.

        - 이러한 멀티 오브젝트 트랜젝션은 여러 데이터들이 싱크되어야 할때 필요로 한다.

- 이메일 어플리케이션 예제

    - 상황 설정

        - 읽지 않은 메시지의 게수를 보여줄 때 다음과 같은 쿼리를 사용할 수 있다.

            ```sql
            SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true
            ```

        - 메일 개수가 많아지면 쿼리가 느려져, 다른 필드에 읽지 않은 메시지 개수를 저장하기로 했다.

            - 새로운 메일이 들어오면 unread count를 늘리도록 구성했다.

    - user2는 다음 상황에서 메일박스 리스트에는 읽지 않은 메시지가 있는데, 읽지 않은 메시지는 0개로 잘못된 데이터를 볼 수 있다. 

        [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/3151bd2e-b6cb-4fbf-a4e8-b6e15ddae8ab)

    - Isolation은 이러한 상황에서 updated counter와 이메일을 동시에 삽입하거나, 둘다 삽입하지 않아 inconsistent한 상황이 발생하지 않도록 보장하여 이러한 이슈를 해결한다. 

    - atomicity는 이메일이 입력되고 카운터 업데이트가 실패했을 때를 처리한다.

        [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/c4b417de-d8ed-477b-8603-a6501fa710f7)

        - atomic transaction에서, counter가 실패하면 트랜젝션 abort되고 email도 롤백된다.

- 멀티 오브젝트 트랜젝션은 어떤 읽기/쓰기가 같은 트랜젝션인지 결정하는 방법을 필요로 한다.

    - RDB는 클라이언트의 DB로의 TCP 커넥션에 기반하여 결정한다.

        - 모든 커넥션에서 begin transaction, commit 사이 모든 statement가 트랜젝션으로 처리된다.

    - 대부분의 다른 DB는 이러한 operation을 그룹화하는 방법이 없다.

        - 멀티 오브젝트 처리 API가 있어도, 이게 필수적으로 트랜젝션이라는 의미를 하지 않는다.

### Single-object writes

- Atomicity와 Isolation은 단일 객체 변경에서도 적용된다.

- 20KB JSON 문서를 DB로 작성한다고 가정한다.

    - 네트워크 커넥션이 10KB 전송 후 interrupt되었으면 DB는 파싱 불가능한 데이터 일부를 저장할까?

    - DB가 디스크로 이전 값을 덮어쓰는 도중 전원이 나간다면, 과거 데이터와 새로운 데이터를 섞어서 저장할까?

    - 다른 클라이언트가 업데이트 중에 문서를 조회하면, 부분적으로 업데이트된 값을 제공할까?

- 이로 인해, 스토리지 엔진은 atomicity와 isolation을 하나의 노드에서 단일 오브젝트 레벨로 제공한다.

    - Atomicity는 크래쉬 복구를 위해 로그를 사용하는 방식으로 구현된다.

    - Isolation은 각 오브젝트에 락을 제공해 하나의 쓰레드만 접근 가능하도록 하여 구현한다.

- 어떤 DB는 increment operation 같은 더 복잡한 atomic 연산을 제공한다.

    - read-modify-write의 사이클의 필요성을 없앤다. 

    - 유사하게 유명한 것으로 다른 존재가 동시에 데이터를 변경하지 않았을 때만 쓰기를 수행하는  compare-and-set 연산이 있다

- 단일 객체 연산은 여러 클라이언트가 동시에 쓰기를 수행할 때 소실이 발생하지 않도록 하여 유용하다.

    - 별개로 트랜젝션은 여러 연산을 하나의 실행 단위로 묶는 것으로 이해해야 한다.

### The need for multi-object transactions

- 많은 분산스토리지는 여러 개의 파티션간 구현이 어렵기도 하고, 높은 성능과 가용성을 제공하기 위해 멀티 오브젝트 트랜젝션을 포기한다.

    - 분산 DB에서 근본적으로 트랜젝션 구현 자체가 안되는 것은 아니다.

- 멀티 오브젝트 트랜젝션이 필요한 경우들이 존재하고, 다음과 같이 고려해볼 수 있다.

    -  관계형 모델에서 테이블의 하나의 row는 다른 테이블의 row로 이어지는 외래 키를 가질 수 있다.

        - 멀티 오브젝트 트랜젝션은 이러한 참조가 항상 유효하도록 보장한다.

        - 참조가 있는 여러 개의 레코드를 삽입할 때, 외래 키가 적절하며 최신임을 보장한다.

    - 문서 모델은 join이 없어, 비정규화를 주로 사용한다.

        - 비정규화된 데이터를 수정할 때, 여러개의 문서를 일관되게 최신으로 수정할 수 있어야 한다.

    - DB에서 세컨더리 인덱스를 사용하면 인덱스는 값을 변경할 때 마다 업데이트되어야 한다.

        - 트랜젝션 격리가 없으면 세컨드 인댁스가 수정되지 않아 인덱스 한쪽에만 보여질 수 있다.

### Handling errors and aborts

- 트랜젝션의 주요 기능은 에러가 발생하면 abort하고, retry 할 수 있는 것이다.

    - ACID는 이러한 철학에 기반한다. DB가 ACID의 보장을 위반할 것 같으면 트랜젝션을 버린다.

- 리더리스 복제를 사용하는 저장소는 best effort에 기반해 동작한다.

    - DB는 가능한 모든 작업을 수행하고, 에러가 발생해도 이미 수행한 작업을 undo하지 않는다.

    - 에러를 recover하는 것은 DB의 몫이다.

- 에러는 피할 수 없이 발생하는데 개발자들은 항상 에러핸들링보단 좋은 길로만 생각한다.

    - abort의 목적은 안전한 retry에 있다.

- abort한 트랜젝션을 재시도하는 것은 단순하고 효과적이지만, 완벽하진 않다.

    - 트랜젝션이 실제로 성공했는데 네트워크 오류로 클라이언트로 성공 여부를 전달하지 못했을 때

        - 클라이언트는 실패로 간주하고, 어플리케이션 레벨의 방어 로직이 없으면 다시 시도해서 결국 2번 실행되는 결과로 이어진다.

    - 에러가 과부하로 발생했으면, 재시도는 문제를 키울 뿐이다.

        - 이러한 피드백 사이클을 피하기 위해, retry 횟수를 제한하고, 지수적 백오프, 과부하 오류를 다른 오류와 다르게 처리하여 해결할 수 있다.

    - 에러가 일시적 오류 이후에 retry되면 괜찮은 경우도 있다.

        - 근데 제약조건 위반같은 영속적인 에러는 retry가 의미가 없다.

    - 트랜젝션이 DB 외부로 영향을 주는 경우엔 트랜젝션이 abort되어도 사이드 이펙트가 발생할 수 있다.

        - 외부 API랑 트랜젝션 쓰는 경우 트랜젝션 abort되도 외부 api는 undo 안된다.

    - 클라이언트 프로세스가 retry중에 죽으면 쓰려던 데이터는 그냥 날아가는거다.

# Weak Isolation Levels

- 두개의 트랜젝션이 같은 데이터를 접근하지 않으면 안전하게 병렬 실행이 가능하다.

    - 동시성 이슈는 하나의 트랜젝션이 데이터를 읽는 중에 다른 트랜젝션이 그 데이터를 수정하려 할 때, 아니면 두 트랜젝션이 같은 데이터를 수정하려 할때 발생한다.

- 동시성 버그는 타이밍으로 맞춰져야 하기 때문에 테스트로 찾기 어려우며, 추론하기도 어렵다.

    - 특히 큰 어플리케이션에서 다른 코드가 DB로 접근하는지 알지 못하는 경우는 더 어렵다.

- DB는 동시성 이슈를 트랜젝션 격리로 어플리케이션 레이어에 숨기고자 한다.

    - 이론상으로는 격리로 모든 동시성이 존재하지 않는 것 처럼 만들어야 한다.

    - 실제로는 Serializable 격리는 성능상 비용이 있고, DB는 이러한 성능 비용을 내지 않으려 한다.

        - 시스템이 더 이해하기 어렵고, 버그로 이어질 수 있는데도 약한 레벨의 트랜젝션만 보장하는 이유

- 약한 트랜젝션으로 인해 발생하는 동시성 오류는 이론적 문제가 아닌, 실질적인 금전 손실로 이어진다.

    - 금융 기관으로부터 조사로 이어질 수 있으며, 고객의 데이터가 오염될 수 있다.

    - 많은 ACID 보장 RDB들도 약한 격리를 제공할 수 있으며, 버그를 예방한다고 보장못한다. 

- 툴에 의존하는 것이 아닌, 존재하는 동시성 문제를 이해하고 예방하는 법을 찾아야 한다.

## Read Committed

- 트랜젝션 격리의 가장 기본적인 레벨

- 두 개의 보장을 제공함

    - DB에서 데이터를 읽을 때 커밋된 데이터만 읽음 (no dirty reads)

    - DB에 데이터를 쓸 때 커밋된 데이터만 덮어쓰기 함 (no dirty writes)

### No Dirty Reads

- dirty read : 쓰기 도중 커밋되지 않은 데이터나 abort된 데이터가 있을 때, 다른 트랜젝션이 이걸 읽는 것

- Read Committed 격리 레벨의 트랜젝션은 dirty read를 예방해야 한다.

    - 트랜젝션의 어떤 쓰기도 커밋 이후에 다른 트랜젝션이 볼 수 있어야 한다.

    [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/f5ec18b9-4a6c-46b2-b0cc-11a3656de9f4)

- Dirty Read를 방지하는 이유

    - 트랜젝션이 여러 객체를 수정하는 경우 dirty read는 다른 트랜젝션이 일부 수정만 확인하게 한다.

        - 일부만 업데이트된 상태를 보는 것은 유저에게 혼란스러울 수 있으며, 다른 트랜젝션이 잘못된 선택을 하도록 한다.

    - 트랜젝션은 abort되면, 작성된 내용이 롤백될 수 있다.

        - DB가 dirty read를 허용하는 경우, 트랜젝션이 롤백될 데이터를 볼 수 있게 된다.

### No dirty writes

- dirty write: 수정이 아직 커밋되지 않았을 때, 다른 트랜젝션이 이를 덮어쓰는 경우

- read committed 격리 레벨의 트랜젝션은 dirty write를 방지해야 한다.

    - 첫번째 쓰기를 커밋하거나 abort하는 방법을 사용한다.

- dirty write를 방지하여 동시성 문제를 해결할 수 있다.

    - 트랜젝션이 여러 객체를 업데이트 하는 경우, dirty write는 잘못된 결과로 이어질 수 있다.

        - 2명의 유저가 동시에 하나의 차를 사려 할 때, 영수증이 구매 처리와 다른 유저로 갈 수 있다.

            [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/fc1c968a-5d70-4d0d-b08c-b061206169fe)

    - 두개의 카운터 증가 연산에 대해 race condition을 방지할 수 없다.

### Implementing read commited

- DB는 행 레벨의 락을 사용해 dirty write를 방지한다.

    - 트랜젝션이 특정 객체를 수정하려 할 때, 객체에 대한 lock을 획득한 후 트랜젝션이 commit되거나 abort될 때 까지 잡고 있는다.

    - 주어진 객체에 대해 하나의 트랜젝션만 락을 얻을 수 있고, 다른 트랜젝션은 같은 객체를 수정하기 위해서는 락이 풀릴때까지 기다리거나, 그 이전에 abort된다.

    - 이러한 락은 DB가 read commitment 모드에서 자동으로 수행한다.

- dirty read를 방지하는 방법

    - write처럼 락을 사용하여, 읽기를 수행할 때 락을 획득하고, 읽은 후 release 하는 방법이 있다.

        - 하나의 오래 걸리는 쓰기 트랜젝션이 많은 읽기 트랜젝션을 블로킹하여 잘 작동하지 않는다.

        - 읽기만 수행하는 트랜젝션의 응답 시간이 길어지며, operability에 나쁘다.

    - 작성된 모든 객체에 대해 DB가 과거 커밋된 값과 쓰기 락을 갖고 있는 트랜젝션이 새로 작성한 값을 모두 저장하고 있는 것이다.

        - 트랜젝션이 진행중이더라도, 다른 트랜젝션이 과거 값을 읽어올 수 있다.

## Snapshot Isolation and Repetable Read

- read committed 격리는 abort, dirty read, dirty write를 방지하며, 트랜젝션이 없는 것보다 유용한 기능을 제공한다.

    - 하지만 동시성 버그가 발생할 여지는 아직도 많다.

- 계좌 이체 상황에서 앨리스가 1000불을 2개의 계좌에 500불씩 갖고 있다고 가정하자.

    [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/e6905576-cb55-4def-bd58-aa58fc910a35)

    - 100불을 한 계좌에서 다른 계좌로 옮길 때, 운이 나쁘게 잔액 조회 하는 중에 transfer가 처리된다고 하자.

        - 하나의 계좌 500불, 하나의 계좌는 400불을 보게 될 수도 있다.

    - 이러한 상태를 nonrepeatable read 혹은 read skew라고 한다.

- read committed 격리 레벨에서는 read skew를 허용하지만, 일시적 비일관성을 허용할 수 없는 상황이 존재한다.

    - 전체 DB를 백업을 하는 경우, 백업 프로세스를 동작하면서 쓰기 연산을 수행할 수 있어야 한다.

        - 백업의 일부 파트는 데이터의 오래된 버전을, 다른 파트는 새로운 버전을 갖고 있을 수 있다.

    - DB의 큰 파트를 스캔하는 쿼리를 수행하는 경우도 있따.

        - 이러한 경우도 파트별로 다른 시점을 관측하면 nonsense가 발생할 수 있다.

- 스냅샷 격리가 가장 일반적인 솔루션이다.

    - 각 트랜젝션 읽기는 데이터베이스의 지속적인 스냅샷으로부터 수행한다.

        - 트랜젝션은 DB로 커밋되는 모든 데이터를 트랜젝션의 시작 시점에서 본다.

        - 다른 트랜젝션이 중간에 데이터를 수정해도 각 트랜젝션은 시작시점의 발생한 데이터를 본다.

    - 백업이나 analytics같은 긴 읽기 쿼리에서 유용하다.

    - 쿼리 실행 중에 해당 쿼리가 처리하는 데이터를 변경할 수 있으면 쿼리의 의미 해석이 어려워진다.

        - 트랜젝션이 DB의 특정시점이 frozen된 일관된 스냅샷을 볼 수 있으면, 이해가 쉬워진다.

### Implementing snapshot isolation

- read commited 격리와 유사하게, 스냅샷 격리의 구현은 write lock을 사용해 dirty write를 방지한다.

    - 쓰기 연산을 하는 트랜젝션은 같은 객체로 쓰기를 수행하는 트랜젝션을 블로킹한다.

    - 읽기는 어떤 락도 필요로 하지 않는다.

- 스냅샷 격리의 핵심 원칙은 reader가 writer를 블로킹하지 않고, 반대도 블로킹하지 않는 것.

    - 두 쿼리간의 락 제한 없이 쓰기를 수행하면서 긴 읽기 쿼리를 일관된 스냅샷에서 수행하도록 한다.

- DB는 객체의 여러개의 커밋 버전을 저장한다.

    - 다양한 진행중인 트랜젝션이 다른 시점의 DB의 state를 볼 수 있기 때문

    - 여러 개의 버전의 객체를 저장하기 때문에, Multi-version Concurrency Control(MVCC)라고도 한다.

    - read commited 격리만 지원하는 경우 과거, 커밋되지 않은 쓰기 후 2개의 버전만 저장한다.

        - 스냅샷 격리를 지원하는 스토리지 엔진은 read committed 격리에도 MVCC를 사용한다.

- MVCC 기반 스냅샷 격리는 Postgre에서 다음과 같이 구현되었다.

    [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/8eff9256-78a9-4d40-a7ff-ac62c79e4b6d)

    - 트랜젝션이 시작되면, 항상 증가하고 unique한 트랜젝션 ID가 부여된다.

        - 트랜젝션이 쓰기를 수행할 때 마다, 쓰기한 데이터에 트랜젝션 ID를 태그한다.

    - 테이블의 각 행은 created_by 필드를 갖고, 입력한 테이블의 트랜젝션 ID를 저장한다.

    - 각 행은 또한 처음에는 비어있는 deleted_by 필드를 갖고 있다.

        - 트랜젝션이 행을 삭제하면, 처음에는 실제로 지워지지 않고 deleted_by 필드에 트랜젝션 ID를 삽입한다.

        - 이후 어떤 트랜젝션도 제거한 데이터에 접근할 수 없으면 DB의 가비지 컬렉터 프로세스가 마크된 행들을 제거하고, 공간을 비운다.

    - 수정은 delete와 create로 해석된다.

    - 하단에 visibility 규칙에 따라 다음과 같이 동작한다.

        - 트랜젝션 12가 account 2를 읽을 때, 트랜젝션 13이 룰 3번으로 무시되며 삭제된 500이 밸런스로 반환된다.

### Visibility rules for observing a consistent snapshot

- 트랜젝션이 DB로부터 읽을 때, txid를 사용해 어떤 객체가 보이고 안보일지를 결정한다. 

- visibility 룰을 주의 깊게 정의해, DB는 어플리케이션에 DB의 일관된 스냅샷을 다음과 같이 제공한다.

    1. 트랜젝션의 시작 시점에 DB는 진행중인 트랜젝션의 리스트를 리스트로 반든다.

        - 이 시점의 트랜젝션에서 발생한 쓰기는 결과적으로 커밋되었어도 무시된다.

    2. abort된 트랜젝션이 수행한 쓰기는 모두 무시한다.

    3. 이후의 txid로 발생된 모든 쓰기는 커밋 여부와 상관 없이 무시된다.

    4. 다른 모든 쓰기는 쿼리에서 보여진다.

- 위의 규칙은 객체의 생성과 제거에 모두 사용된다.

- 다음 두가지 조건을 모두 만족할 때 객체가 보여진다.

    - reader의 트랜젝션이 시작될 때, 객체를 생성한 트랜젝션이 커밋되었을 때

    - 삭제로 마킹되지 않았거나, 마킹되었어도 트랜젝션이 reader 트랜젝션 시작 전에 커밋되지 않았을 때

- 긴 트랜젝션은 스냅샷을 긴 시간동안 사용하여, 오래전에 덮어쓰기되거나 삭제된 데이터를 읽을 수 있다.

    - 값을 자리 안에서 수정하는 대신 값이 바뀔때마다 새로운 버전을 만들어 작은 오버헤드로 일관된 스냅샷을 제공할 수 있다.

### Indexes and snapshot isolation

- 멀티버전 DB에서 인덱스는 어떻게 작동할까?

    - 한 옵션은 인덱스가 객체의 모든 버전을 가리키고, 현재 트랜젝션에서 어떤 것이 보이지 말아야 할지 가리는 필터를 만드는 것이다.

    - GC가 사용되지 않는 오래된 버전을 제거하면, 인덱스에서도 제거되어야 한다. 

- 실제로 많은 구현 디테일이 MVCC의 성능을 결정한다.

    - PG는 같은 오브젝트의 다른 버전이 같은 페이지에 맞으면 인덱스를 수정하지 않는 최적화를 사용한다

    - CouchDB, Datomic등은 B-tree 의 append-only/copy-on-write 변형을 사용한다.

        - 수정시 트리의 페이지를 재작성하지 않고, 수정된 페이지의 새로운 카피를 만든다.

            - 트리의 루트까지 부모 페이지는 복제되고, 새로운 버전의 자식 페이지를 가리키도록 한다.

            - 영향받지 않은 페이지는 변경되지 않고 남아있는다.

        - append-only B-tree에서 모든 쓰기 트랜젝션은 새로운 B-tree 루트를 만들고, 특정 루트는 트랜젝션이 생성되었을 때의 일관된 스냅샷이다.

            - 쓰기가 B-tree를 수정하지 않기 때문에 트랜젝션 id로 객체를 필터할 필요가 없다.

        - 이러한 접근은 압축과 가비지 콜렉션을 위한 백그라운드 프로세스를 필요로 한다.

### Repeatable read and naming confusion

- 스냅샷 격리는 특히 읽기 전용 트랜젝션에서 유용하지만, DB마다 이름이 다르다.

    - 오라클은 serializable, PG랑 MySQL은 repeatable read라고 한다.

- 이름의 비일관성은 SQL 표준이 스냅샷 격리가 발명되기 이전인 System R에 기반하기 때문에 발생했다.

    - 대신 스냅샷 격리와 유사한 repeatable read를 정의했다.

    - PG와 MySQL은 스냅샷 격리가 SQL 표준의 요구사항을 만족하니 표준의 compliance로 여긴다.

    - SQL 표준의 격리 레벨은 편향되었다. 모호하고, 부정확하며, 구현에 독립적이지 않다.

        - 결과적으로 repeatable read가 무슨뜻인지는 아무도 모른다.

## Preventing Lost Updates

- dirty write 이외에도 동시 쓰기로 인한 conflict가 발생할 수 있다.

- Lost update problem

    - 어플리케이션이 DB에 read-modify-write를 수행할 때 발생한다.

    - 두개의 트랜젝션이 동시에 이를 수행하면, 먼저 수행된 쓰기는 이후 수행된 쓰기에 반영되지 않아 소실된다.

- 다음과 같은 상황에서 이러한 패턴이 발생한다.

    - 카운터를 증가시키거나 계좌 잔액을 수정할 때

        - 현재 값을 읽고, 새로운 값을 연산한 후, 연산된 값을 다시 작성할 때

    - 복잡한 값에 대해 로컬 변경을 만들 때

        - JSON 도큐먼트 속 리스트에 element를 추가하는 경우

        - 도큐먼트를 파싱하여 수정한 후 도큐멘트를 다시 작성할 때

    - 두 유저가 동시에 위키 페이지를 수정할 때 각 유저가 변경을 전체 페이지를 서버로 보내는 방식으로 저장하는 경우

### Atomic write operations

- 많은 DB는 read-modify-write 사이클을 코드 레벨에서 하지 않도록 atomic 쓰기 연산을 제공한다.

    - 코드를 atomic 연산으로 처리할 수 있는게 최선의 솔루션이다.

    - 모든 쓰기가 atomic operation으로 쉽게 표현될 수 있지 않지만, 사용될 수 있는 경우에는 최선이다.

- atomic 연산은 읽기 시점에 객체에 대한 독점적 락을 얻는 방식으로 구현된다.

    - 다른 트랜젝션은 업데이트가 처리될 때 까지 읽기가 불가능하다.

        - cursor stability라고 불리는 테크닉이다.

- 모든 atomic 연산을 싱글 스레드로 실행하도록 강요하는 방법도 존재한다.

- ORM은 atomic 연산 사용할 수 있어도 의도치 않게 read-modify-write를 사용하게 되기 쉽다.

### Explicit locking

- lost update를 방지하는 또다른 방법

- DB에 내장된 atomic 연산이 필수적인 기능을 제공하지 않는 경우, 어플리케이션이 명시작으로 객체에 수정될 예정이라고 락을 설정할 수 있다.

    - 어플리케이션은 read-and-write 사이클을 수행할 수 있게 되고, 다른 트랜젝션이 동시에 읽기를 수행하려 하면 사이클이 종료될 때 까지 기다리게 된다.

- 여러 유저가 동시에 움직이는 멀티플레이 게임을 생각하면, atomic 연산으로 충분하지 않다.

    - 플레이어가 규칙대로 음직이도록 보장해야 하는데, 이는 DB 쿼리로 구현할 수 없는 로직일 수 있다.

- 어플리케이션 로직에서 락을 추가하는걸 잊어 레이스 컨디션으로 이어지지 않도록 고려해야 한다.

### Automatically detecting lost updates

- 트랜젝션을 병렬적으로 실행하도록 한 후, 트랜젝션 매니저가 lost update를 발견하면 트랜젝션을 abort하고 사이클을 재시도하도록 할 수도 있다.

- 이러한 접근의 장점은 DB가 이를 스냅샷 격리와 결합해 효율적으로 확인할 수 있다는 서이다.

    - PG의 repeatable read, 오라클의 serializable, SQL Server의 스냅샷 격리 레벨 모두 자동으로 lost update의 발생을 감지하고 발생하는 트랜젝션을 abort 한다.

    - MySQL과 InnoDB의 repeatable read는 이걸 감지 못한다.

- DB가 주어진 스냅샷 격리를 만족하기 위해서는 무조건 lost update를 피해야 한다고 주장도 있다.

    - MySQL은 이러한 기준에서 스냅샷 격리를 제공하지 않는다.

- Lost Update Detection은 어플리케이션이 특수한 DB 기능을 사용하지 않아도 되어 유용하다.

    - 락이나 atomic 연산을 사용하는 것을 잊어도, lost update 감지가 자동으로 이루어져 에러에 대응할 수 있게 된다.

### Compare-and-set

- 트랜젝션을 제공하지 않는 DB에서 atomic compare-and-set 연산을 수행할 수 있다.

- 연산의 목적은 읽기 시점 이후로 데이터가 바뀌지 않았을 때만 변경을 수행하도록 하는 것이다.

    - 현재 값이 이전에 읽은 값과 다른 경우, 업데이트가 적용되지 않고, read-modify-write 사이클이 다시 수행된다.

- 다음과 같은 쿼리로 수행할 수 있다.

    ```sql
    UPDATE wiki_pages SET content = 'new content' WHERE id = 1234 AND content = 'old content';
    ```

    - 컨텐츠가 변경되어 old content가 아닌 경우, update문은 아무것도 하지 않는다.

        - update문의 효과가 있었는지 확인 후 retry하도록 나다.

- DB의 where 문이 과거 스냅샷을 읽어올수 있다면 컨디션을 만족하기 떄문에 lost update를 막을 수 없다.

    - 사용하는 DB의 compare-and-set 연산이 안전한지 확인해보고 이걸 사용하도록 하자.

### Conflict resolution and replication

- 복제를 사용하는 DB에서, lost update를 예방하는 것은 다른 차원의 문제다.

    - 여러 개의 노드에 복제본을 갖고 있으며, 데이터가 동시에 다른 노드에서 수정될 수 있다.

    - lost update를 막기 위해서는 추가적인 과정을 필요로 한다.

- 락과 compare-and-set 연산은 데이터가 하나의 최신 카피만 있음을 가정한다.

    - 멀티리더나 리더리스 복제 사용하면 동시에 여러 쓰기를 수행할 수 있으며, 복제가 비동기적으로 일어나 하나의 최신 카피만 존재함을 보장할 수 없다.

    - 락과 compare-and-set을 이러한 컨택스트에서 사용할 수 없게 된다.

- 복제 DB에서 일반적인 접근은 동시성 쓰기를 허용하여 충돌하는 버전을 만들고, 어플리케이션이나 특수한 데이터 구조로 이를 resolve하고 하나로 병합하도록 하는 것이다.

- 아토믹 연산은 복제가 있는 상황에서도 잘 작동한다. 특히 누적 연산인 경우.

    - 값이 다른 클라이언트에서 동시에 수정이 발생한 경우 Riak은 수정을 업데이트가 소실되지 않는 방법으로 병합한다.

- Last write wins같은 충돌 해결법은 lost update에 취약하지만, 많은 DB에서 기본이다.

## Write Skew and Phantoms

- 의사의 온콜 쉬프트를 결정하는 어플리케이션의 예시

    - 온콜에 적어도 한 명의 의사가 있어야 한다. 의사는 시프트를 포기할 수 있으며, 적어도 한명의 동료가 온콜로 있어야 한다고 가정한다.

    - 두명의 의사가 특정 시프트에 있다고 가정하는데, 두명의 의사가 동시에 시프트를 포기하면?

        [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/1608a8c5-94c6-4edd-9a1f-c4991f978b15)

        - 각 트랜젝션에서 어플리케이션은 2명 이상의 온콜 의사가 있는지 확인한다.

            - 있으면 한명은 빠져도 된다.

        - DB는 스냅샷 격리를 사용하기 때문에, 두 의사 모두 2를 반환한다.

            - 두 트랜젝션 모두 다음 스테이지로 이동한다.

        - 두 의사 모두 온콜에서 빠지게 되고, 온콜에 아무도 남지 않게 되어 최소 1명이라는 제약 조건을 위반하게 된다.

### Characterizing write skew

- 이러한 비정상적 상황을 write skew라고 한다.

    - 두개의 서로 다른 객체를 수정하는 것이기 때문에 dirty write나 lost update가 아니다.

    - 충돌이 발생했다고 보기도 어렵지만, 명백한 race condition이다.

    - 이러한 이상 동작은 트랜젝션이 동시에 수행되어서 발생한거다.

- write skew를 lost update의 일반화로 생각할 수 있다.

    - Write skew는 같은 object에 동시에 접근해 수정할 때도 발생할 수 있다.

        - 다른 트랜젝션이 다른 객체를 수정할 수도 있음

    - 다른 트랜젝션이 동시에 같은 트랜젝션애 접근하는 특수한 경우 dirty write와 lost update가 발생

        - 타이밍에 의해 발생한다.

- Write skew는 lost update보다 방어 로직에 제한이 크다

    - Atomic 단일 객체 연산은 여러 개의 객체가 관여되어 의미가 없다.

    - lost update 자동 탐지도 도움이 되지 않는다.

        - write skew는 자동으로 탐지되지 않는다.

        - 자동으로 write skew를 막으려면 serialization 격리밖에 방법이 없다.

    - 한명 이상의 의사가 온콜임을 보장하려면, 여러 개의 객체에 대한 constraint를 추가해야 한다.

        - 데이터베이스중에 제약 사항을 설정하도록 할 수 있는 경우가 있다.

        - 대부분의 데이터베이스는 여러 객체에 대한 제약조건을 내장하고 있지 않지 않다.

            - DB에 따라 트리거나 materialized view로 구현할 수 있는 경우도 있다.

    - serialization 격리 레벨을 사용할 수 없다면 최선은 트랜젝션이 사용하는 모든 행에 락을 거는 것이다.

        ```sql
        BEGIN TRANSACTION;
        
        SELECT * FROM doctors
        WHERE on_call = true AND shift_id = 1234 FOR UPDATE;
        
        UPDATE doctors
        SET on_call = false
        WHERE name = 'Alice' AND shift_id = 1234;
        
        COMMIT;
        ```

        - FOR UPDATE는 조회한 모든 행에 락을 거는 것.

### More Examples of write skew

- write skew는 소수 이슈처럼 보였지만, 인지하고 나면 다양한 상황에서 발생할 수 있다.

- 회의실 예약 시스템

    - 회의실을 예약할 때, 그 시간에 예약된 사람이 없는지 확인하고, 없으면 예약을 한다.

    - 스냅샷 격리는 다른 유저가 동시에 충돌하는 미팅을 생성하는 것을 방지할 수 없다.

        - 또다시 serializable 격리를 필요로 한다.

- 멀티플레이 게임

    - lost update 막기위해서는 락을 쓰면 됐지만, 플레이어 두 명이 같은 위치로 이동하거나 게임의 규칙을 위반하는 것을 막을 수 없다.

        - 룰에 따라 unique constant를 쓸 수 있는 경우도 있지만, 아닌 경우는 write skew에 취약해진다.

- username 등록

    - 각 유저가 유니크한 닉네임을 설정하도록 할때, 두명의 유저가 동시에 같은 닉네임을 신청할 수 있다.

    - 트랜젝션으로 이름을 사용중인지 확인하고, 존재하지 않으면 계정을 생성하도록 할 수 있다.

        - snapshot isolation에서는 안전하지 않다.

    - 이건 unique constraint로 쉽게 방어가 가능하다.

- Preventing double-spending

    - 돈이나 포인트를 쓰게 하는 서비스는 가진것보다 더 큰 자원을 쓰도록 하면 안된다.

### Phantoms causing write skew

- 이 모든 예시는 유사한 패턴을 따른다.

    1. SELECT 쿼리가 요구 조건을 만족하는지 search한다.

    2. 첫번째 쿼리 결과를 확인하고, 어플리케이션이 어떻게 진행할지 결정한다.

    3. 어플리케이션이 계속 진행하면, DB로 쓰기를 수행하고 트랜젝션을 커밋한다.

        - 이 쓰기의 영향은 스탭 2번의 과거 상태를 변화시킨다.

            - 쓰기를 커밋한 후 스탭 1의 SELECT 쿼리를 반복했을때 search condition이 달라졌기 때문에 다른 결과가 나온다

- 다른 순서로 일어날 수도 있다. 쓰기를 한 후 SELECT를 하고 이 결과에 따라 커밋할 수도 있다.

- 하나의 트랜젝션에서 쓰기의 결과가 다른 트랜젝션의 검색 결과를 바꾸는 것을 phantom이라 한다.

    - 온콜 예시에선, 스텝 3에서 수정된 쿼리가 스탭 1에서 반환되었던 쿼리였다.

    - 다른 예제는 행의 존재여부를 확인하고, 없을 때 추가한다.

    - 스탭1의 쿼리 결과가 아무런 행을 반환하지 않으면, SELECT FOR UPDATE로 락을 획득할 수 없다. 

    - 스냅샷 격리는 읽기 쿼리에서는 phantom을 막지만, 읽기-쓰기 트랜젝션에서는 write skew의 까다로운 케이스로 이어질 수 씨다.

### Materializing conflicts

- phantom의 문제가 락을 붙일 수 없어서 발생한다면, lock object를 인공적으로 만들면 어떨까?

    - 미팅룸 예약의 경우 타임슬롯과 룸에 대한 테이블을 만들고, 시간 간격을 설정해두는 것이다.

    - 트랜젝션이 특정 시간과 원하는 회의실에 해ㅐ 락을 할 수 있게 된다.

- 이러한 접근을 materializing conflict라 한다.

    - phantom을 DB에 존재하는 견고한 행 집합에 대한 lock conflict로 전환하는 것이다.

    - 어떤 방법으로 할 지 어렵고 에러에 취약해질 수 있다.

        - 또한 동시성 컨트롤 동작을 어플리케이션 데이터 모델로 빼는것도 좋지 않다.

    - 이렇기에, 다른 대안이 불가능할때 사용한다.

        - serializable 격리 레벨이 더 선호된다.

# Serializability

- read commitment와 snapshot으로 방어할 수 없는 race condition이 존재한다.

    - 격리 레벨은 이해하기 어렵고, 데이터베이스들 사이에 일관되게 구현되지 않는다.

    - 어플리케이션 코드를 봤을 때, 특정 격리 레벨에서 안전한지 판단하기 어렵다.

        - 거대한 어플리케이션에선 특히 어떤게 동시에 일어나는지 판단이 어렵다.

    - race condition을 탐지하는 좋은 툴이 없다.

        - 정적 분석이 도움은 되나, 리서치 테크닉들이 실용적인 사용을 찾지 못했다.

    - 새로운 문제들이 아니다. 연구자들의 결론은 serializable 격리 레벨을 사용하는 것이다.

- Serializable 격리

    - 가장 강력한 격리 레벨로 여겨진다.

    - 병렬적으로 실행되는 트랜젝션 레벨에서도 결과가 동시성 없이 순차적으로 실행한 것과 동일함을 보장한다.

        - 순서대로 실행했을 때 정상적으로 동작했으면, 동시에 실행해도 정상적으로 동작함을 보장한다.

-  현재 Serializability를 제공하는 DB는 다음 3개의 테크닉 중 하나를 사용한다.

    - 문자 그대로 트랜젝션을 순차적으로 실행한다.

    - Two-phase locking (수십년간 가능한 유일한 옵션이었음)

    - Optimistic 동시성 컨트롤 테크닉 (serializable snapshot isolation)

## Actual Serial Execution

- 동시성 문제를 히나느 자아 간단한 방법은 동시성을 없애는 것이다.

    - 한번에 하나의 트랜젝션을 순차적으로 싱글스레드로 돌리는 것.

    - 트랜젝션 충돌을 감지하고 예방할 필요를 피할 수 있다.

- 명백한 아이디어 같지만, 2007년에야 트랜젝션 실행에 싱글 스레드 루프를 사용하기 시작했다.

    - 멀티 쓰레드 동시성이 성능을 위해 필수적이라고 여겨졌지만, 2가지 발전이 재논의로 이어졌다.

        - 램의 가격이 저렴해지면서, 대부분의 유즈 케이스에서 전체 데이터셋을 저장할 수 있게 되었다.

            - 트랜젝션에 필요한 데이터가 모두 메모리에서 접근 가능하다면 디스크 IO가 줄어 훨씬 빠르게 작동한다.

        - DB 설계자들이 OLTP 트랜젝션은 수명이 짧고 작은 읽기/쓰기 워크로드가 대부분이라는 사실을 깨달았다.

            - 대조적으로 분석 쿼리는 읽기만 수행하고, serial 실행 루프 외부의 일관된 스냅샷에서 실행할 수 있다.

- 싱글 쓰레드가 어떨땐 동시성 지원보다 빠르게 동작한다.

    - 락킹의 코디네이션에서 오는 오버헤드가 없기 떄문

    - 처리량이 하나의 CPU 코어로 제한된다. 대부분을 싱글 스레드로 만드려면, 트랜젝션은 전통적인 형태와 다르게 디자인 되어야 한다.

### Encapsulating transactions in stored procedures

- 초기 DB에서 트랜젝션은 유저 행동 전반의 플로우를 통과하도록 하는 서이었다.

    - DB 설계자들은 프로세스 전반을 하나의 프로세스로 정의하여 atomic하게 커밋되길 바랬다.

    - 사람의 반응은 생각보다 느렸다.

        - DB 트랜젝션이 사용자의 입력을 기다려야 한다면, DB는 많은 양의 idle 상태 동시성 트랜젝션을 지원해야 할 수도 있다.

        - 대부분의 DB는 효율적으로 후애 못하고, 거의 대부분의 OLTP는 사용자와의 상호작용을 피하고 트랜젝션의 비활성화를 줄여 짧은 시간에 구성되도록 발전했다.

    - 웹에서도 트랜젝션은 하나의 HTTP 요청에서 커밋되도록 구성된다.

        - 여러 개의 HTTP 요청으로 트랜젝션을 분리하지 않는다.

- 트랜젝션은 여전히 서버와 클라이언트의 상호 작용에서 한번의 하나의 명령만 실행하도록 구성된다.

    - 어플리케이션은 쿼리를 만들고, 결과를 읽고, 첫 쿼리의 결과로 다른 쿼리를 만든다.

        - 쿼리와 결과는 DB 서버와 어플리케이션 코드 사이에서 전송된다.

    - 이러한 상호작용 스타일의 트랜젝션에서 DB와 어플리케이션간 네트워크 통신 시간이 많이 소요된다.

        - 동시성을 허용하지 않고 한번에 하나의 트랜젝션만 처리한다면, 처리량이 크게 떨어진다.

            - DB는 어플리케이션이 현재 트랜젝션의 다음 쿼리를 기다리며 지연시간이 길어진다.

        - 이런 경우 Stored Procedure가 네트워크, 디스크 IO 없이 굉장히 빠르게 작동한다.

            [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/ae8cdc4b-6243-472c-a635-c9062a001cf5)

### Pros and cons of store procedures

- 관계형 DB에서 오랫동안 존재했고, 표준이지만 다양한 이유로 평가가 나쁘다.

    - 각 DB마다 stored procedure 작성언어가 다르다.

        - 이러한 언어는 일반 목적의 프로그래밍 언어의 발전을 따라가지 못해, 현재 시점에선 구식이다.

        - 프로그래밍 언어같은 라이브러리 생태계는 존재하지 않는다.

    - 어플리케이션에 비해 DB에서 실행되는 코드를 관리하기 어렵다.

        - 디버깅이 어려우며, 버전 컨트롤과 배포는 더 어렵고, 테스트도 쉽지 않으며, 모니터링을 위한 메트릭 수집 시스템 통합도 어렵다.

    - DB는 하나의 DB를 여러 어플리케이션이 공유하기 때문에 어플리케이션보다 훨씬 성능에 민감하다.

        - stored procedure를 잘못 작성하면 어플리케이션에 작성하는 것보다 큰 문제로 이어진다.

- stored procedure의 현대 구현에선 PL/SQL을 사용하지 않고 일반 목적 프로그래밍 언어를 사용한다.

    - VoltDB는 Java나 Groovy를, Datomic은 Java나 Clojure를, Redis는 Lua를 사용한다.

- stored procedure와 인메모리 데이터를 통해, 모든 트랜젝션을 싱글 스레드로 돌리는게 가능해졌다.

    - IO를 기다릴 필요가 없고 동시성 제어 메커니즘을 필요로 하지 않아 싱글 스레드로 좋은 성능을 낸다.

- VoltDB는 복제를 위해 stored procedure를 사용한다.

    - 트랜젝션의 쓰기를 하나의 노드에서 다른 노드로 복제하는게 아니라, 각 레플리카에 동일한 stored procedure를 실행한다.

    - stored procedure를 결정론적으로 설정한다(다른 노드에서 실행해도 같은 결과를 내야 한다.)

        - 현재시간 같은걸 사용할땐 특수한 결정론적 API를 사용한다.

### Partitioning

- 모든 트랜젝션을 연속적으로 실행하면 동시성 컨트롤이 매우 쉬워지지만, 트랜젝션의 처리량을 단을 서니의 싱글 CPU 코어로 한정시킨다.

    - 읽기 전용 트랜젝션은 스냅샷 격리로 어디서든 처리하지만, 쓰기 워크로드가 많은 어플리케이션에서 싱글 스레드 트랜젝션은 큰 병목이 될 수 있다.

- 여러개의 CPU로 스케일링하려면 데이터를 파티션하는 방법이 있다.

    - 데이터셋을 파티셔닝하여 트랜젝션이 단일 파티션에서만 일어나도록 하면 각 파티션은 다른 파티션과 독립적인 트랜젝션 처리 스레드를 얻게된다.

        - 각 CPU에 파티션을 부여해서, 트랜젝션을 CPU 개수만큼 선형적으로 스케일링한다.

- 여러개의 파티션을 접근해야 하는 트랜젝션에선 DB가 접근하는 파티션들을 코디네이팅해야한다.

    - stored procedure는 전체 시스템의 serializability를 위해 락을 획득하는 프로세스를 수행해야 한다.

    - 멀티 파티션 트랜젝션은 추가적인 코디네이션 오버헤드가 필요해, 단일 파티션 트랜젝션보다 느리다.

        - 머신을 추가한다고 성능이 좋아지지도 않는다.

### Summary of serial execution

- 특정 제약조건이 있지만 serializable 격리를 구현하는 방법 중 하나가 되었다.

    - 느린 트랜젝션은 모든 트랜젝션을 멈추기 때문에 모든 트랜젝션은 작고 빨라야 한다.

    - 전체 데이터셋이 메모리에 들어갈 수 있어야 한다.

        - 접근을 잘 안하는 데이터는 디스크로 옮겨져야 하지만, 싱글 스레딩이라 시스템이 느려진다.

    - 쓰기 처리량은 싱글 CPU에서 처리될 수 있어야 하거나, 트랜젝션이 크로스파티션 코디네이션 사용하지 않고도 파티션 될 수 있어야 한다.

    - 크로스 파티션 트랜젝션도 가능하나, 사용되는 경우에 제한이 걸린다.

## Two-Phase Locking

- 30년간 유일하게 주로 사용된 락킹 알고리즘이다.

    - Two Phase Commit과는 완전히 다른 내용이다.

- Two Phase Locking

    - 두개의 트랜젝션이 동시에 같은 객체로 작성하려 할 때, 락은 하나가 처리 될 때 까지 다른 하나의 트랜젝션이 기다리게 한다.

    - Two Phase Locking은 비슷하지만 lock의 요구사항이 훨씬 아하다.

        - 여러개의 트랜젝션은 쓰기가 없는 동안 동시에 읽는 것이 가능하다.

        - 쓰기 락을 획득하면, 독점적인 접근이 필요해진다.

            - 트랜젝션 A가 객체를 읽고 B가 쓰기를 수행하려 하면 B는 A의 트랜젝션이 끝날때까지 기다려야 한다.

            - 트랜젝션 A가 객체를 쓰고 B가 읽기를 수행하려 해도 B는 A의 트랜젝션이 끝날때까지 기다려야 한다.

- 2PL에서 writer는 다른 writer뿐만 아니라 reader를 블락하고, reader에 블락된다.

    - 스냅샷 격리는 readers never block writer, writer never block reader라는 원칙을 쓴다.

        - 스냅샷 격리와 2PL의 가장 핵심적인 차이가 된다.

- 2PL이 serializability를 제공하기 때문에, 지금까지 논의된 모든 race condition을 방어한다.

### Implementation of two-phase locking

- 2PL은 MySQL과 SQL Server의 serializable 격리 레벨에 사용된다.

- reader와 writer의 블락킹은 DB의 각 객체에 락을 갖도록 구현한다. 락은 다음과 같이 사용된다.

    - 트랜젝션이 읽기를 수행하려면, 공유 모드로 락을 획득한다.

        - 공유 락을 획득하는 트랜젝션들은 동시에 락을 획득하여 실행될 수 있다.

        - 다른 트랜젝션이 독점 락을 이미 획득했다면 락을 얻기 위해 기다려야 한다.

    - 트랜젝션이 쓰기를 수행하려면, 독점 모드로 락을 획득한다.

        - 다른 트랜젝션은 어떤 상태던 동시에 락을 획득할 수 없다.

        - 이미 객체에 락이 존재한다면, 트랜젝션은 기다려야 한다.

    - 트랜젝션이 읽기를 수행하고 이후 쓰기를 수행하면, 공유 락을 독점 락으로 버그레이드한다.

        - 업그레이드는 독점 락을 획득하는 것과 동일하게 동작한다.

    - 트랜젝션이 락을 획득한 후, 트랜젝션 종료까지 락을 갖고 있는다.

        - 이름이 2-phase인 이유

            - 첫 phase는 락을 획득하는 것, 두번째 phase는 모든 락을 해제하는 것이다.

- 락이 많이 사용되기 때문에, 트랜젝션끼리 서로 락이 해제되길 기다리는 deadlock이 발생한다.

    - DB는 데드락을 자동으로 발견하여 하나를 abort한다.

    - abort된 트랜젝션은 어플리케이션에서 다시 시도한다.

### Performance of two-phase locking

- 2PL의 큰 단점이고, 70년대 이후로 잘 사용되지 않은 이유가 성능때문이다.

    - 트랜젝션 처리량과 쿼리 반응 속도가 약한 격리보다 훨씬 떨어진다.

    - 락을 다 획득하고 풀어주는데 오버헤드와, 감소한 동시 처리로 인해 발생한다.

        - 설계상 2개의 동시성 트랜젝션이 레이스 컨디션으로 이어질 수 있는 경우 하나가 블락된다.

- 전통적 RDB는 입력을 기다리는 상호작용 어플리케이션을 위해 설계되었기 때문에 트랜젝션의 길이를 제한하지 않는다

    - 결과적으로 하나의 트랜젝션이 다른 트랜젝션을 기다려야 한다면, 얼마나 기다려야 하는지 모른다.

    - 모든 트랜젝션을 짧게 만들어도, 같은 객체를 수정하려는 큐가 형성될 수 있다.

        - 어떤것을 하려면 한참을 기다려야 하는 경우가 발생한다.

    - 이러한 이유로, 2PL을 쓰는 DB는 불안정한 지연시간을 갖고, 워크로드 사이 경쟁이 있으면 높은 퍼센타일에서 느려진다.

        - 하나의 트랜젝션이 느리거나 많은 락을 획득하면 전체 시스템이 느려진다.

        - 이러한 불안정성은 강건한 연산이 필요할 때 문제가 된다.

### Predicate locks

- serializable 격리에서 phantom을 무조건 방어해야 한다.

- 회의실 예약 예제

    - 하나의 트랜젝션이 특정 타임 윈도우에서 룸에 대해 존재하는 예약을 모두 탐색한다는 것

        - 다른 트랜젝션은 같은 룸과 시간 범위에 대해 동시에 읽기나 수정을 하지 못한다.

    - 이를 구현하려면 이론적으로는 Predicate lock을 필요로 한다.

        - 공유 / 독점 록과 유사하게 동작하지만, 특정 객체가 아닌 상태를 만족하는 범위에 대해 동작한다.

- Predicate lock은 다음과 같이 접근을 제한한다.

    - 트랜젝션 A가 특정 조건에 맞는 객체를 읽으려 할 때, 공유 모드 predicate 락을 획득해야 한다.

        - 다른 트랜젝션이 범위를 포함하는 독점 락을 자고 있으면, A는 락이 풀릴때까지 기다려야 한다. 

    - 트랜젝션 A가 객체에 쓰기, 삭제를 수행하려면 과거 값이나 새로운 값이 이미 존재하는 predicate lock에 포함되는지 확인해야 한다.

        - 다른 트랜젝션이 범위를 포함하는 독점 락을 갖고 있으면, A는 트랜젝션이 끝날때까지 기다려야 한다.

- 키 아이디어는 predicate lock이 아직 존재하지 않는, 미래에 생길 객체에도 적용된다는 것이다. 

    - 2PL이 predicate lock을 포함한다면, DB는 모든 write skew와 레이스 컨디션을 방어해야 한다. 

### Index-range locks

- predicate lock은 잘 작동하지 않는다.

    - 활성화된 트랜젝션에 많은 락이 존재하면, 락 매칭 확인하는 것도 시간이 든다.

    - 대부분의 DB는 2PL을 인덱스범위 락킹으로 구현한다.

        - predicate locking의 단순화된 예상이다.

- 더 큰 객체 집합을 매치시켜 예측을 단순화하는 것이 유용하다.

    - 범위가 더 넓으면 원본 예측과 쓰기가 다 매치하여 더 안전해진다.

- phantom과 write skew에 대해 효율적인 보호를 제공한다.

    - 인덱스 범위 락은 predicate lock만큼 정밀하진 않지만, 오버헤드가 적어 좋은 타협이다.

- 적절한 인덱스에 락을 걸 수 없을때, 테이블 전체에 락을 걸어버린다

    - 성능은 좋지 않지만 안정성을 위한 선택이다.

## Serializable Snapshot Isolation

- serializable 격리와 좋은 성능은 양립할 수 없나?

    - serializable snapshot isolation이라는 방법이 있다.

    - 완전한 serializability를 제공하면서 스냅샷 격리와 비교하여 최소한의 성능 하락만을 갖는다.

- SSI는 싱글 노드 DB(PG 버전 9.1부터)와 분산 DB(FoundationDB)에 모두 사용된다.

    - 다른 동시성 컨트롤 메카니즘에 비해 성숙하지 않고, 현실 성능을 증명하고 있다.

    - 미래의 표준이 될 정도로 충분히 빠를 가능성이 있다.

### Pessimistic versus optimistic concurrency

- 2PL은 비관적 동시성 제어 메커니즘이다.

    - 어떤 것이든 잘못될 수 있다는 가정이다.

    - 어떤 행동을 취하던 상황이 안전해질때까지 기다린다.

    - 멀티 스레드 프로그래밍에서 보호를 위해 사용하는 데이터 구조인 상호 배제와 유사하다.

- Serial execution은 극단적인 비관적 실행이다.

    - 각 트랜젝션이 트랜젝션동안 모든 데이터베이스에 대해 독점 락을 갖는것과 동등하다.

    - 각 트랜젝션을 아주 빠르게 처리하도록 하여 짧은 시간만 락을 갖도록 희생하여 비관성을 달성한다.

- Serialization Snapshot Isolation은 낙관적 동시성 컨트롤 테크닉을 사용한다.

    - 낙관성은 블락킹을 하는 대신 위험할 수 있는 일이 벌어져도 잘 될거라는 기대로 트랜젝션을 계속 진행하는 것이다.

    - 트랜젝션이 커밋하는 시점에 DB가 문제가 발생했는지 확인한다.

        - 문제가 발생했으면 트랜젝션이 abort되고 다시 시도한다.

        - 순차적으로 실행된 트랜젝션만 커밋이 허용된다.

- 많은 트랜젝션이 같은 객체를 접근하려 하면 성능이 떨어진다.

    - 대부분의 트랜젝션이 abort되고 다시 시도해야 한다.

    - 시스템이 이미 최대 처리량에 도달했으면, 다시 시도로 인한 추가적인 로드가 성능을 하락시킨다.

    - 시스템에 충분한 공간이 있고 트랜젝션 컨텐션이 높지 않으면, 낙관적 동시성 컨트롤 테크닉은 비관적 컨트롤보다 빠르다.

        - 컨텐션은 교환 법칙을 만족하는 atomic 연산을 통해 줄일 수 있다.

        - 여러 트랜젝션이 카운트를 증가하려 할때, 어떤 순서로 증가시켜도 상관이 없고, 동시에 충돌 없이 증가시킬 수 있다.

- SSI는 스냅샷 격리에 기반한다.

    - 트랜젝션의 모든 읽기는 DB의 일관된 스냅샷에서 생성된다.

    - 스냅샷 격리 위에 SSI는 쓰기 요청 간 serialization 충돌을 감지하는 알고리즘을 탑재하여, 어떤 트랜젝션을 abort할 지 결정한다.

### Decisions based on an outdated premise

- 스냅샷 격리에서 원본 쿼리의 결과값이 트랜젝션 커밋 시점의 최신값과 다를 수 있다.

    - 그 사이에 트랜젝션이 업데이트 될 수 있기 때문이다.

    - 트랜젝션은 전제에 기반해 행동을 취하는데, 커밋 시점에 오리지널 데이터가 바뀌었으면 전제가 사실이 아니게 되는 것이다.

- 어플리케이션이 쿼리를 생성할 때, DB는 어플리케이션 로직이 쿼리 결과를 어떻게 사용하는지 알 수 없다.

    - DB는 쿼리 결과의 변경이 있으면 모든 쓰기를 invalid하다고 여기는 것이 안전하다.

    - 트랜젝션의 쿼리와 쓰기 간에 인과 의존이 있을 수 있다는 가정을 하는 것이다.

    - serializable 격리를 제공하기 위해, DB는 트랜젝션이 outdate된 전제를 사용하는 트랜젝션을 탐지해야 하고, 사용하는 경우 이를 abort할 수 있어야 한다.

### Detecting stale MVCC

- 트랜젝션이 MVCC의 일관된 스냅샷에서 데이터를 읽으면, 스냅샷 시점에 커밋되지 않은 다른 쓰기를 모두 무시한다.

    - 온콜 예시를 다시 살펴보자.

        [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/17a6d69c-9995-407b-98d0-504fb45d5bcb)

        - 트랜젝션 43번의 커밋 시점에 42번은 이미 커밋이 되었다.

        - 따라서 43번이 읽은 일관된 스냅샷에서 무시한 쓰기가 커밋되어 스냅샷이 영향을 받았고, 따라서 43번의 전제는 더이상 사실이 아니다.

- 이러한 이상을 예방하기 위해 DB는 트랜젝션이 MVCC visibility 규칙에 따라 다른 트랜젝션의 쓰기를 무시해야 하는지 판단해야 한다.

    - 트랜젝션이 커밋할 때, DB는 무시한 write중에 커밋된 것이 있는지 확인하고, 있으면 abort해야 한다.

- 커밋 시점까지 기다리는 이유는 읽기만 수행하는 트랜젝션이면 abort할 필요가 없기 때문이다.

    - write skew 리스크가 없고, 트랜젝션이 읽기를 수행할 때 DB는 이후 쓰기의 존재 여부를 알지 못한다.

    - 필요 없는 abort를 제거하여 SSI는 스냅샷 격리처럼 일관된 스냅샷에서의 긴 읽기 쿼리를 지원한다.

### Detecting writes that affect prior

- 2PL에서 index-range locks를 통해 매칭하는 범위의 모든 인덱스에서 락을 획득했었다.

    - SSI는 다른 트랜젝션을 블락하지 않으면서 유사한 테크닉을 사용할 수 있다.

- 다른 트랜젝션이 읽기 이후 데이터를 수정하는 경우를 살펴보자

    [image](https://app.capacities.io/d1cf29da-a5be-492d-839a-e228b21e0129/7b36f3c7-467a-4cba-ab39-4d088762297d)

    - 트랜젝션 42, 43은 모두 shift 1234에 대해 온콜 의사를 찾는다.

        - 이후 트랜젝션 43번은 42번에 과거 읽기 쿼리가 outdate되었다고 알리고, 반대도 알린다.

        - 42번이 먼저 커밋을 성공하면 커밋 이전에 43이 42번에 영향을 끼쳤어도 충돌한 42번이 먼저 커밋되었기 때문에 43번이 abort되어야 한다.

    - shift_id에 대해 인덱스가 있으면, DB는 42번 43번 트랜젝션이 이 데이터를 읽었다는 사실을 기록할 수 있다.

        - DB가 쓰기를 수행할 때, 다른 트랜젝션이 이 인덱스에 영향을 미쳤는지 확인한다.

        - write lock을 획득하는 것과 유사하지만, 커밋시점까지 다른 트랜젝션을 블락킹하는게 아닌 다른 트랜젝션이 읽은 데이터가 최신이 아니라는 사실을 트랜젝션에 알린다.

    - 이 정보는 잠시동안 저장되며, 트랜젝션이 종료되고 모든 동시성 트랜젝션이 종료되면 DB는 어떤 데이터를 읽었는지 잊을 수 있다.

### Performance of serializable snapshot isolation

- 많은 엔지니어링 디테일들이 알고리즘이 현실에서 잘 작동하는지 영향을 미친다.

    - DB가 트랜젝션의 활동을 디테일하게 저장하면 정밀할 수 있으나 bookkeeping 오버헤드가 커진다.

    - 디테일이 줄어들면 빨라지지만 필요한 것보다 더 많은 트랜젝션이 abort된다.

- 어떤 경우에는 트랜젝션이 다른 트랜젝션이 덮어쓴 데이터를 읽어와도 괜찮다.

    - 발생한 다른 일의 경우에 따라, 결과적으로 실행이 serializable함을 증명할 수 있는 경우가 있다.

        - PG가 이렇게 하여 abort를 줄인다.

- 2PL과 비교해 SSI의 큰 장점은 하나의 트랜젝션이 다른 트랜젝션을 블락킹하지 않는 것이다.

    - 스냅샷 격리처럼, writer는 reader를 블락하지 않고, 반대도 성립한다.

        - 이러한 설계 원칙이 쿼리 레이턴시를 예측 가능하고 편차를 줄인다.

    - 읽기 쿼리는 락 없이 일관된 스냅샷으로 작동해, 읽기 중심 워크로드에 적합하다.

- serial execution과 비교했을 때 단일 CPU에 한정되지 않는다.

    - FoundationDB는 serialization 충돌을 여러개의 머신으로 분산하여, 높은 처리량으로 스케일 할 수 있도록 한다.

    - 데이터가 여러 머신으로 파티션될 수 있지만, 트랜젝션은 여러 개의 파티션에서 serializable 격리를 보장하면서 읽기 / 쓰기를 수행할 수 있다.

- abort 비율이 SSI의 전반적인 성능을 결정한다.

    - 읽기 / 쓰기가 긴 시간동안 이루어지는 트랜젝션은 conflict와 abort로 이어지기 쉽다.

        - 성능을 위해 SSI 트랜젝션을 짧게 설계해야 한다.

        - 긴 읽기 쿼리는 괜찮을 수 있다.

    - 그래도 2PL이나 serial execution보다는 덜 민감하다.

